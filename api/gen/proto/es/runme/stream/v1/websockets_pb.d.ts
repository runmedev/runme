// @generated by protoc-gen-es v2.6.0 with parameter "target=js+dts,import_extension=none,json_types=true"
// @generated from file runme/stream/v1/websockets.proto (package runme.stream.v1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { Code, CodeJson } from "../../../google/rpc/code_pb";
import type { ExecuteRequest, ExecuteRequestJson, ExecuteResponse, ExecuteResponseJson } from "../../runner/v2/runner_pb";

/**
 * Describes the file runme/stream/v1/websockets.proto.
 */
export declare const file_runme_stream_v1_websockets: GenFile;

/**
 * Represents websocket-level status (e.g., for auth, protocol, or other errors).
 *
 * @generated from message runme.stream.v1.WebsocketStatus
 */
export declare type WebsocketStatus = Message<"runme.stream.v1.WebsocketStatus"> & {
  /**
   * @generated from field: google.rpc.Code code = 1;
   */
  code: Code;

  /**
   * @generated from field: string message = 2;
   */
  message: string;
};

/**
 * Represents websocket-level status (e.g., for auth, protocol, or other errors).
 *
 * @generated from message runme.stream.v1.WebsocketStatus
 */
export declare type WebsocketStatusJson = {
  /**
   * @generated from field: google.rpc.Code code = 1;
   */
  code?: CodeJson;

  /**
   * @generated from field: string message = 2;
   */
  message?: string;
};

/**
 * Describes the message runme.stream.v1.WebsocketStatus.
 * Use `create(WebsocketStatusSchema)` to create a new message.
 */
export declare const WebsocketStatusSchema: GenMessage<WebsocketStatus, {jsonType: WebsocketStatusJson}>;

/**
 * Ping message for protocol-level keep-alive
 *
 * @generated from message runme.stream.v1.Ping
 */
export declare type Ping = Message<"runme.stream.v1.Ping"> & {
  /**
   * @generated from field: int64 timestamp = 1;
   */
  timestamp: bigint;
};

/**
 * Ping message for protocol-level keep-alive
 *
 * @generated from message runme.stream.v1.Ping
 */
export declare type PingJson = {
  /**
   * @generated from field: int64 timestamp = 1;
   */
  timestamp?: string;
};

/**
 * Describes the message runme.stream.v1.Ping.
 * Use `create(PingSchema)` to create a new message.
 */
export declare const PingSchema: GenMessage<Ping, {jsonType: PingJson}>;

/**
 * Pong message for protocol-level keep-alive response
 *
 * @generated from message runme.stream.v1.Pong
 */
export declare type Pong = Message<"runme.stream.v1.Pong"> & {
  /**
   * @generated from field: int64 timestamp = 1;
   */
  timestamp: bigint;
};

/**
 * Pong message for protocol-level keep-alive response
 *
 * @generated from message runme.stream.v1.Pong
 */
export declare type PongJson = {
  /**
   * @generated from field: int64 timestamp = 1;
   */
  timestamp?: string;
};

/**
 * Describes the message runme.stream.v1.Pong.
 * Use `create(PongSchema)` to create a new message.
 */
export declare const PongSchema: GenMessage<Pong, {jsonType: PongJson}>;

/**
 * WebsocketRequest defines the message sent by the client over a websocket.
 * The request is a union of types that indicate the type of message.
 *
 * @generated from message runme.stream.v1.WebsocketRequest
 */
export declare type WebsocketRequest = Message<"runme.stream.v1.WebsocketRequest"> & {
  /**
   * @generated from oneof runme.stream.v1.WebsocketRequest.payload
   */
  payload: {
    /**
     * Add other payloads here as needed.
     *
     * @generated from field: runme.runner.v2.ExecuteRequest execute_request = 1;
     */
    value: ExecuteRequest;
    case: "executeRequest";
  } | { case: undefined; value?: undefined };

  /**
   * Protocol-level ping for frontend heartbeat. Unlike websocket servers which
   * have a spec-integral heartbeat (https://developer.mozilla.org/en-US/docs/Web/API/WebWebsockets_API/Writing_WebWebsocket_servers#pings_and_pongs_the_heartbeat_of_websockets),
   * we need to specify our own to cover client->server. The integral heartbeat
   * only works server->client and the browser sandbox is not privy to it.
   * Once the server receives a ping, it will send a pong response with the
   * exact same timestamp.
   *
   * @generated from field: runme.stream.v1.Ping ping = 100;
   */
  ping?: Ping;

  /**
   * Optional authorization header, similar to the HTTP Authorization header.
   *
   * @generated from field: string authorization = 200;
   */
  authorization: string;

  /**
   * Optional Known ID to track the origin cell/block of the request.
   *
   * @generated from field: string known_id = 210;
   */
  knownId: string;

  /**
   * Optional Run ID to track and resume execution.
   *
   * @generated from field: string run_id = 220;
   */
  runId: string;
};

/**
 * WebsocketRequest defines the message sent by the client over a websocket.
 * The request is a union of types that indicate the type of message.
 *
 * @generated from message runme.stream.v1.WebsocketRequest
 */
export declare type WebsocketRequestJson = {
  /**
   * Add other payloads here as needed.
   *
   * @generated from field: runme.runner.v2.ExecuteRequest execute_request = 1;
   */
  executeRequest?: ExecuteRequestJson;

  /**
   * Protocol-level ping for frontend heartbeat. Unlike websocket servers which
   * have a spec-integral heartbeat (https://developer.mozilla.org/en-US/docs/Web/API/WebWebsockets_API/Writing_WebWebsocket_servers#pings_and_pongs_the_heartbeat_of_websockets),
   * we need to specify our own to cover client->server. The integral heartbeat
   * only works server->client and the browser sandbox is not privy to it.
   * Once the server receives a ping, it will send a pong response with the
   * exact same timestamp.
   *
   * @generated from field: runme.stream.v1.Ping ping = 100;
   */
  ping?: PingJson;

  /**
   * Optional authorization header, similar to the HTTP Authorization header.
   *
   * @generated from field: string authorization = 200;
   */
  authorization?: string;

  /**
   * Optional Known ID to track the origin cell/block of the request.
   *
   * @generated from field: string known_id = 210;
   */
  knownId?: string;

  /**
   * Optional Run ID to track and resume execution.
   *
   * @generated from field: string run_id = 220;
   */
  runId?: string;
};

/**
 * Describes the message runme.stream.v1.WebsocketRequest.
 * Use `create(WebsocketRequestSchema)` to create a new message.
 */
export declare const WebsocketRequestSchema: GenMessage<WebsocketRequest, {jsonType: WebsocketRequestJson}>;

/**
 * WebsocketResponse defines the message sent by the server over a websocket.
 * The response is a union of types that indicate the type of message.
 *
 * @generated from message runme.stream.v1.WebsocketResponse
 */
export declare type WebsocketResponse = Message<"runme.stream.v1.WebsocketResponse"> & {
  /**
   * @generated from oneof runme.stream.v1.WebsocketResponse.payload
   */
  payload: {
    /**
     * Add other payloads here as needed.
     *
     * @generated from field: runme.runner.v2.ExecuteResponse execute_response = 1;
     */
    value: ExecuteResponse;
    case: "executeResponse";
  } | { case: undefined; value?: undefined };

  /**
   * Protocol-level pong for frontend heartbeat. Once the server receives
   * a ping, it will send a pong response with the exact same timestamp.
   * This allows the frontend (client) to detect if the connection is
   * still alive or stale/inactive. See WebsocketRequest's ping for more details.
   *
   * @generated from field: runme.stream.v1.Pong pong = 100;
   */
  pong?: Pong;

  /**
   * Optional websocket-level status.
   *
   * @generated from field: runme.stream.v1.WebsocketStatus status = 200;
   */
  status?: WebsocketStatus;

  /**
   * Optional Known ID to track the origin cell/block of the request.
   *
   * @generated from field: string known_id = 210;
   */
  knownId: string;

  /**
   * Optional Run ID to track and resume execution.
   *
   * @generated from field: string run_id = 220;
   */
  runId: string;
};

/**
 * WebsocketResponse defines the message sent by the server over a websocket.
 * The response is a union of types that indicate the type of message.
 *
 * @generated from message runme.stream.v1.WebsocketResponse
 */
export declare type WebsocketResponseJson = {
  /**
   * Add other payloads here as needed.
   *
   * @generated from field: runme.runner.v2.ExecuteResponse execute_response = 1;
   */
  executeResponse?: ExecuteResponseJson;

  /**
   * Protocol-level pong for frontend heartbeat. Once the server receives
   * a ping, it will send a pong response with the exact same timestamp.
   * This allows the frontend (client) to detect if the connection is
   * still alive or stale/inactive. See WebsocketRequest's ping for more details.
   *
   * @generated from field: runme.stream.v1.Pong pong = 100;
   */
  pong?: PongJson;

  /**
   * Optional websocket-level status.
   *
   * @generated from field: runme.stream.v1.WebsocketStatus status = 200;
   */
  status?: WebsocketStatusJson;

  /**
   * Optional Known ID to track the origin cell/block of the request.
   *
   * @generated from field: string known_id = 210;
   */
  knownId?: string;

  /**
   * Optional Run ID to track and resume execution.
   *
   * @generated from field: string run_id = 220;
   */
  runId?: string;
};

/**
 * Describes the message runme.stream.v1.WebsocketResponse.
 * Use `create(WebsocketResponseSchema)` to create a new message.
 */
export declare const WebsocketResponseSchema: GenMessage<WebsocketResponse, {jsonType: WebsocketResponseJson}>;
