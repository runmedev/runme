// @generated by protoc-gen-es v2.9.0 with parameter "target=js+dts,import_extension=none,json_types=true"
// @generated from file runme/contents/v1/contents.proto (package runme.contents.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file runme/contents/v1/contents.proto.
 */
export declare const file_runme_contents_v1_contents: GenFile;

/**
 * FileInfo describes a filesystem entry.
 *
 * @generated from message runme.contents.v1.FileInfo
 */
export declare type FileInfo = Message<"runme.contents.v1.FileInfo"> & {
  /**
   * Path is the full path to the file or directory.
   *
   * @generated from field: string path = 1;
   */
  path: string;

  /**
   * Name is the base name of the file or directory.
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * Type indicates whether this entry is a file or directory.
   *
   * @generated from field: runme.contents.v1.FileType type = 3;
   */
  type: FileType;

  /**
   * SizeBytes is the size of the file in bytes.
   *
   * @generated from field: int64 size_bytes = 4;
   */
  sizeBytes: bigint;

  /**
   * LastModifiedUnixMs is the last modification time in milliseconds since epoch.
   *
   * @generated from field: int64 last_modified_unix_ms = 5;
   */
  lastModifiedUnixMs: bigint;

  /**
   * Sha256Hex is the hex-encoded SHA-256 hash of the file contents.
   * Empty if hashing was not requested.
   *
   * @generated from field: string sha256_hex = 6;
   */
  sha256Hex: string;
};

/**
 * FileInfo describes a filesystem entry.
 *
 * @generated from message runme.contents.v1.FileInfo
 */
export declare type FileInfoJson = {
  /**
   * Path is the full path to the file or directory.
   *
   * @generated from field: string path = 1;
   */
  path?: string;

  /**
   * Name is the base name of the file or directory.
   *
   * @generated from field: string name = 2;
   */
  name?: string;

  /**
   * Type indicates whether this entry is a file or directory.
   *
   * @generated from field: runme.contents.v1.FileType type = 3;
   */
  type?: FileTypeJson;

  /**
   * SizeBytes is the size of the file in bytes.
   *
   * @generated from field: int64 size_bytes = 4;
   */
  sizeBytes?: string;

  /**
   * LastModifiedUnixMs is the last modification time in milliseconds since epoch.
   *
   * @generated from field: int64 last_modified_unix_ms = 5;
   */
  lastModifiedUnixMs?: string;

  /**
   * Sha256Hex is the hex-encoded SHA-256 hash of the file contents.
   * Empty if hashing was not requested.
   *
   * @generated from field: string sha256_hex = 6;
   */
  sha256Hex?: string;
};

/**
 * Describes the message runme.contents.v1.FileInfo.
 * Use `create(FileInfoSchema)` to create a new message.
 */
export declare const FileInfoSchema: GenMessage<FileInfo, {jsonType: FileInfoJson}>;

/**
 * @generated from message runme.contents.v1.ListRequest
 */
export declare type ListRequest = Message<"runme.contents.v1.ListRequest"> & {
  /**
   * Path is the directory to list.
   *
   * @generated from field: string path = 1;
   */
  path: string;

  /**
   * IncludeHashes requests SHA-256 hashes for each returned item.
   *
   * @generated from field: bool include_hashes = 2;
   */
  includeHashes: boolean;
};

/**
 * @generated from message runme.contents.v1.ListRequest
 */
export declare type ListRequestJson = {
  /**
   * Path is the directory to list.
   *
   * @generated from field: string path = 1;
   */
  path?: string;

  /**
   * IncludeHashes requests SHA-256 hashes for each returned item.
   *
   * @generated from field: bool include_hashes = 2;
   */
  includeHashes?: boolean;
};

/**
 * Describes the message runme.contents.v1.ListRequest.
 * Use `create(ListRequestSchema)` to create a new message.
 */
export declare const ListRequestSchema: GenMessage<ListRequest, {jsonType: ListRequestJson}>;

/**
 * @generated from message runme.contents.v1.ListResponse
 */
export declare type ListResponse = Message<"runme.contents.v1.ListResponse"> & {
  /**
   * @generated from field: repeated runme.contents.v1.FileInfo items = 1;
   */
  items: FileInfo[];
};

/**
 * @generated from message runme.contents.v1.ListResponse
 */
export declare type ListResponseJson = {
  /**
   * @generated from field: repeated runme.contents.v1.FileInfo items = 1;
   */
  items?: FileInfoJson[];
};

/**
 * Describes the message runme.contents.v1.ListResponse.
 * Use `create(ListResponseSchema)` to create a new message.
 */
export declare const ListResponseSchema: GenMessage<ListResponse, {jsonType: ListResponseJson}>;

/**
 * @generated from message runme.contents.v1.ReadRequest
 */
export declare type ReadRequest = Message<"runme.contents.v1.ReadRequest"> & {
  /**
   * Path is the file to read.
   *
   * @generated from field: string path = 1;
   */
  path: string;

  /**
   * IncludeHash requests a SHA-256 hash of the file contents.
   *
   * @generated from field: bool include_hash = 2;
   */
  includeHash: boolean;
};

/**
 * @generated from message runme.contents.v1.ReadRequest
 */
export declare type ReadRequestJson = {
  /**
   * Path is the file to read.
   *
   * @generated from field: string path = 1;
   */
  path?: string;

  /**
   * IncludeHash requests a SHA-256 hash of the file contents.
   *
   * @generated from field: bool include_hash = 2;
   */
  includeHash?: boolean;
};

/**
 * Describes the message runme.contents.v1.ReadRequest.
 * Use `create(ReadRequestSchema)` to create a new message.
 */
export declare const ReadRequestSchema: GenMessage<ReadRequest, {jsonType: ReadRequestJson}>;

/**
 * @generated from message runme.contents.v1.ReadResponse
 */
export declare type ReadResponse = Message<"runme.contents.v1.ReadResponse"> & {
  /**
   * Content is the raw file contents.
   *
   * @generated from field: bytes content = 1;
   */
  content: Uint8Array;

  /**
   * Info is metadata about the file that was read.
   *
   * @generated from field: runme.contents.v1.FileInfo info = 2;
   */
  info?: FileInfo;
};

/**
 * @generated from message runme.contents.v1.ReadResponse
 */
export declare type ReadResponseJson = {
  /**
   * Content is the raw file contents.
   *
   * @generated from field: bytes content = 1;
   */
  content?: string;

  /**
   * Info is metadata about the file that was read.
   *
   * @generated from field: runme.contents.v1.FileInfo info = 2;
   */
  info?: FileInfoJson;
};

/**
 * Describes the message runme.contents.v1.ReadResponse.
 * Use `create(ReadResponseSchema)` to create a new message.
 */
export declare const ReadResponseSchema: GenMessage<ReadResponse, {jsonType: ReadResponseJson}>;

/**
 * @generated from message runme.contents.v1.StatRequest
 */
export declare type StatRequest = Message<"runme.contents.v1.StatRequest"> & {
  /**
   * Path is the file or directory to stat.
   *
   * @generated from field: string path = 1;
   */
  path: string;

  /**
   * IncludeHash requests a SHA-256 hash of the file contents.
   *
   * @generated from field: bool include_hash = 2;
   */
  includeHash: boolean;
};

/**
 * @generated from message runme.contents.v1.StatRequest
 */
export declare type StatRequestJson = {
  /**
   * Path is the file or directory to stat.
   *
   * @generated from field: string path = 1;
   */
  path?: string;

  /**
   * IncludeHash requests a SHA-256 hash of the file contents.
   *
   * @generated from field: bool include_hash = 2;
   */
  includeHash?: boolean;
};

/**
 * Describes the message runme.contents.v1.StatRequest.
 * Use `create(StatRequestSchema)` to create a new message.
 */
export declare const StatRequestSchema: GenMessage<StatRequest, {jsonType: StatRequestJson}>;

/**
 * @generated from message runme.contents.v1.StatResponse
 */
export declare type StatResponse = Message<"runme.contents.v1.StatResponse"> & {
  /**
   * @generated from field: runme.contents.v1.FileInfo info = 1;
   */
  info?: FileInfo;
};

/**
 * @generated from message runme.contents.v1.StatResponse
 */
export declare type StatResponseJson = {
  /**
   * @generated from field: runme.contents.v1.FileInfo info = 1;
   */
  info?: FileInfoJson;
};

/**
 * Describes the message runme.contents.v1.StatResponse.
 * Use `create(StatResponseSchema)` to create a new message.
 */
export declare const StatResponseSchema: GenMessage<StatResponse, {jsonType: StatResponseJson}>;

/**
 * @generated from message runme.contents.v1.WriteRequest
 */
export declare type WriteRequest = Message<"runme.contents.v1.WriteRequest"> & {
  /**
   * Path is the file to write.
   *
   * @generated from field: string path = 1;
   */
  path: string;

  /**
   * Content is the raw bytes to write.
   *
   * @generated from field: bytes content = 2;
   */
  content: Uint8Array;

  /**
   * ExpectedVersion is a SHA-256 hash for conditional writes.
   * When set, the write only succeeds if the current file hash matches.
   *
   * @generated from field: optional string expected_version = 3;
   */
  expectedVersion?: string;

  /**
   * Mode controls behaviour when the target file already exists.
   *
   * @generated from field: runme.contents.v1.WriteMode mode = 4;
   */
  mode: WriteMode;
};

/**
 * @generated from message runme.contents.v1.WriteRequest
 */
export declare type WriteRequestJson = {
  /**
   * Path is the file to write.
   *
   * @generated from field: string path = 1;
   */
  path?: string;

  /**
   * Content is the raw bytes to write.
   *
   * @generated from field: bytes content = 2;
   */
  content?: string;

  /**
   * ExpectedVersion is a SHA-256 hash for conditional writes.
   * When set, the write only succeeds if the current file hash matches.
   *
   * @generated from field: optional string expected_version = 3;
   */
  expectedVersion?: string;

  /**
   * Mode controls behaviour when the target file already exists.
   *
   * @generated from field: runme.contents.v1.WriteMode mode = 4;
   */
  mode?: WriteModeJson;
};

/**
 * Describes the message runme.contents.v1.WriteRequest.
 * Use `create(WriteRequestSchema)` to create a new message.
 */
export declare const WriteRequestSchema: GenMessage<WriteRequest, {jsonType: WriteRequestJson}>;

/**
 * @generated from message runme.contents.v1.WriteResponse
 */
export declare type WriteResponse = Message<"runme.contents.v1.WriteResponse"> & {
  /**
   * Info is metadata about the file after the write.
   *
   * @generated from field: runme.contents.v1.FileInfo info = 1;
   */
  info?: FileInfo;
};

/**
 * @generated from message runme.contents.v1.WriteResponse
 */
export declare type WriteResponseJson = {
  /**
   * Info is metadata about the file after the write.
   *
   * @generated from field: runme.contents.v1.FileInfo info = 1;
   */
  info?: FileInfoJson;
};

/**
 * Describes the message runme.contents.v1.WriteResponse.
 * Use `create(WriteResponseSchema)` to create a new message.
 */
export declare const WriteResponseSchema: GenMessage<WriteResponse, {jsonType: WriteResponseJson}>;

/**
 * @generated from message runme.contents.v1.RenameRequest
 */
export declare type RenameRequest = Message<"runme.contents.v1.RenameRequest"> & {
  /**
   * OldPath is the current location of the file or directory.
   *
   * @generated from field: string old_path = 1;
   */
  oldPath: string;

  /**
   * NewPath is the desired location.
   *
   * @generated from field: string new_path = 2;
   */
  newPath: string;

  /**
   * ExpectedVersion is a SHA-256 hash for conditional renames.
   * When set, the rename only succeeds if the current file hash matches.
   *
   * @generated from field: optional string expected_version = 3;
   */
  expectedVersion?: string;
};

/**
 * @generated from message runme.contents.v1.RenameRequest
 */
export declare type RenameRequestJson = {
  /**
   * OldPath is the current location of the file or directory.
   *
   * @generated from field: string old_path = 1;
   */
  oldPath?: string;

  /**
   * NewPath is the desired location.
   *
   * @generated from field: string new_path = 2;
   */
  newPath?: string;

  /**
   * ExpectedVersion is a SHA-256 hash for conditional renames.
   * When set, the rename only succeeds if the current file hash matches.
   *
   * @generated from field: optional string expected_version = 3;
   */
  expectedVersion?: string;
};

/**
 * Describes the message runme.contents.v1.RenameRequest.
 * Use `create(RenameRequestSchema)` to create a new message.
 */
export declare const RenameRequestSchema: GenMessage<RenameRequest, {jsonType: RenameRequestJson}>;

/**
 * @generated from message runme.contents.v1.RenameResponse
 */
export declare type RenameResponse = Message<"runme.contents.v1.RenameResponse"> & {
  /**
   * Info is metadata about the entry at its new location.
   *
   * @generated from field: runme.contents.v1.FileInfo info = 1;
   */
  info?: FileInfo;
};

/**
 * @generated from message runme.contents.v1.RenameResponse
 */
export declare type RenameResponseJson = {
  /**
   * Info is metadata about the entry at its new location.
   *
   * @generated from field: runme.contents.v1.FileInfo info = 1;
   */
  info?: FileInfoJson;
};

/**
 * Describes the message runme.contents.v1.RenameResponse.
 * Use `create(RenameResponseSchema)` to create a new message.
 */
export declare const RenameResponseSchema: GenMessage<RenameResponse, {jsonType: RenameResponseJson}>;

/**
 * @generated from message runme.contents.v1.MkdirRequest
 */
export declare type MkdirRequest = Message<"runme.contents.v1.MkdirRequest"> & {
  /**
   * Path is the directory to create (including parents).
   *
   * @generated from field: string path = 1;
   */
  path: string;
};

/**
 * @generated from message runme.contents.v1.MkdirRequest
 */
export declare type MkdirRequestJson = {
  /**
   * Path is the directory to create (including parents).
   *
   * @generated from field: string path = 1;
   */
  path?: string;
};

/**
 * Describes the message runme.contents.v1.MkdirRequest.
 * Use `create(MkdirRequestSchema)` to create a new message.
 */
export declare const MkdirRequestSchema: GenMessage<MkdirRequest, {jsonType: MkdirRequestJson}>;

/**
 * @generated from message runme.contents.v1.MkdirResponse
 */
export declare type MkdirResponse = Message<"runme.contents.v1.MkdirResponse"> & {
  /**
   * Info is metadata about the created directory.
   *
   * @generated from field: runme.contents.v1.FileInfo info = 1;
   */
  info?: FileInfo;
};

/**
 * @generated from message runme.contents.v1.MkdirResponse
 */
export declare type MkdirResponseJson = {
  /**
   * Info is metadata about the created directory.
   *
   * @generated from field: runme.contents.v1.FileInfo info = 1;
   */
  info?: FileInfoJson;
};

/**
 * Describes the message runme.contents.v1.MkdirResponse.
 * Use `create(MkdirResponseSchema)` to create a new message.
 */
export declare const MkdirResponseSchema: GenMessage<MkdirResponse, {jsonType: MkdirResponseJson}>;

/**
 * FileType distinguishes files from directories.
 *
 * @generated from enum runme.contents.v1.FileType
 */
export enum FileType {
  /**
   * @generated from enum value: FILE_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: FILE_TYPE_FILE = 1;
   */
  FILE = 1,

  /**
   * @generated from enum value: FILE_TYPE_DIRECTORY = 2;
   */
  DIRECTORY = 2,
}

/**
 * FileType distinguishes files from directories.
 *
 * @generated from enum runme.contents.v1.FileType
 */
export declare type FileTypeJson = "FILE_TYPE_UNSPECIFIED" | "FILE_TYPE_FILE" | "FILE_TYPE_DIRECTORY";

/**
 * Describes the enum runme.contents.v1.FileType.
 */
export declare const FileTypeSchema: GenEnum<FileType, FileTypeJson>;

/**
 * WriteMode controls how Write handles existing files.
 *
 * @generated from enum runme.contents.v1.WriteMode
 */
export enum WriteMode {
  /**
   * @generated from enum value: WRITE_MODE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: WRITE_MODE_OVERWRITE_ALWAYS = 1;
   */
  OVERWRITE_ALWAYS = 1,

  /**
   * @generated from enum value: WRITE_MODE_FAIL_IF_EXISTS = 2;
   */
  FAIL_IF_EXISTS = 2,

  /**
   * @generated from enum value: WRITE_MODE_CREATE_OR_TRUNCATE = 3;
   */
  CREATE_OR_TRUNCATE = 3,
}

/**
 * WriteMode controls how Write handles existing files.
 *
 * @generated from enum runme.contents.v1.WriteMode
 */
export declare type WriteModeJson = "WRITE_MODE_UNSPECIFIED" | "WRITE_MODE_OVERWRITE_ALWAYS" | "WRITE_MODE_FAIL_IF_EXISTS" | "WRITE_MODE_CREATE_OR_TRUNCATE";

/**
 * Describes the enum runme.contents.v1.WriteMode.
 */
export declare const WriteModeSchema: GenEnum<WriteMode, WriteModeJson>;

/**
 * ContentsService provides local filesystem access.
 *
 * @generated from service runme.contents.v1.ContentsService
 */
export declare const ContentsService: GenService<{
  /**
   * List returns the entries in a directory.
   *
   * @generated from rpc runme.contents.v1.ContentsService.List
   */
  list: {
    methodKind: "unary";
    input: typeof ListRequestSchema;
    output: typeof ListResponseSchema;
  },
  /**
   * Read returns the contents of a file.
   *
   * @generated from rpc runme.contents.v1.ContentsService.Read
   */
  read: {
    methodKind: "unary";
    input: typeof ReadRequestSchema;
    output: typeof ReadResponseSchema;
  },
  /**
   * Stat returns metadata about a file or directory without reading its contents.
   *
   * @generated from rpc runme.contents.v1.ContentsService.Stat
   */
  stat: {
    methodKind: "unary";
    input: typeof StatRequestSchema;
    output: typeof StatResponseSchema;
  },
  /**
   * Write writes content to a file. Returns ConnectRPC Aborted status code
   * when expected_version is set and does not match the current file hash.
   *
   * @generated from rpc runme.contents.v1.ContentsService.Write
   */
  write: {
    methodKind: "unary";
    input: typeof WriteRequestSchema;
    output: typeof WriteResponseSchema;
  },
  /**
   * Rename moves a file or directory from one path to another. Returns
   * ConnectRPC Aborted status code when expected_version is set and does not
   * match the current file hash.
   *
   * @generated from rpc runme.contents.v1.ContentsService.Rename
   */
  rename: {
    methodKind: "unary";
    input: typeof RenameRequestSchema;
    output: typeof RenameResponseSchema;
  },
  /**
   * Mkdir creates a directory (and any necessary parents).
   *
   * @generated from rpc runme.contents.v1.ContentsService.Mkdir
   */
  mkdir: {
    methodKind: "unary";
    input: typeof MkdirRequestSchema;
    output: typeof MkdirResponseSchema;
  },
}>;

