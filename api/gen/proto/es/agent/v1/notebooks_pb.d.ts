// @generated by protoc-gen-es v2.9.0 with parameter "target=js+dts,import_extension=none,json_types=true"
// @generated from file agent/v1/notebooks.proto (package agent.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { Cell, CellJson } from "../../runme/parser/v1/parser_pb";

/**
 * Describes the file agent/v1/notebooks.proto.
 */
export declare const file_agent_v1_notebooks: GenFile;

/**
 * @generated from message agent.v1.ListCellsRequest
 */
export declare type ListCellsRequest = Message<"agent.v1.ListCellsRequest"> & {
};

/**
 * @generated from message agent.v1.ListCellsRequest
 */
export declare type ListCellsRequestJson = {
};

/**
 * Describes the message agent.v1.ListCellsRequest.
 * Use `create(ListCellsRequestSchema)` to create a new message.
 */
export declare const ListCellsRequestSchema: GenMessage<ListCellsRequest, {jsonType: ListCellsRequestJson}>;

/**
 * @generated from message agent.v1.ListCellsResponse
 */
export declare type ListCellsResponse = Message<"agent.v1.ListCellsResponse"> & {
  /**
   * @generated from field: repeated runme.parser.v1.Cell cells = 2;
   */
  cells: Cell[];
};

/**
 * @generated from message agent.v1.ListCellsResponse
 */
export declare type ListCellsResponseJson = {
  /**
   * @generated from field: repeated runme.parser.v1.Cell cells = 2;
   */
  cells?: CellJson[];
};

/**
 * Describes the message agent.v1.ListCellsResponse.
 * Use `create(ListCellsResponseSchema)` to create a new message.
 */
export declare const ListCellsResponseSchema: GenMessage<ListCellsResponse, {jsonType: ListCellsResponseJson}>;

/**
 * @generated from message agent.v1.GetCellsRequest
 */
export declare type GetCellsRequest = Message<"agent.v1.GetCellsRequest"> & {
  /**
   * @generated from field: repeated string ref_ids = 1;
   */
  refIds: string[];
};

/**
 * @generated from message agent.v1.GetCellsRequest
 */
export declare type GetCellsRequestJson = {
  /**
   * @generated from field: repeated string ref_ids = 1;
   */
  refIds?: string[];
};

/**
 * Describes the message agent.v1.GetCellsRequest.
 * Use `create(GetCellsRequestSchema)` to create a new message.
 */
export declare const GetCellsRequestSchema: GenMessage<GetCellsRequest, {jsonType: GetCellsRequestJson}>;

/**
 * @generated from message agent.v1.GetCellsResponse
 */
export declare type GetCellsResponse = Message<"agent.v1.GetCellsResponse"> & {
  /**
   * @generated from field: repeated runme.parser.v1.Cell cells = 1;
   */
  cells: Cell[];
};

/**
 * @generated from message agent.v1.GetCellsResponse
 */
export declare type GetCellsResponseJson = {
  /**
   * @generated from field: repeated runme.parser.v1.Cell cells = 1;
   */
  cells?: CellJson[];
};

/**
 * Describes the message agent.v1.GetCellsResponse.
 * Use `create(GetCellsResponseSchema)` to create a new message.
 */
export declare const GetCellsResponseSchema: GenMessage<GetCellsResponse, {jsonType: GetCellsResponseJson}>;

/**
 * @generated from message agent.v1.UpdateCellsRequest
 */
export declare type UpdateCellsRequest = Message<"agent.v1.UpdateCellsRequest"> & {
  /**
   * @generated from field: repeated runme.parser.v1.Cell cells = 1;
   */
  cells: Cell[];
};

/**
 * @generated from message agent.v1.UpdateCellsRequest
 */
export declare type UpdateCellsRequestJson = {
  /**
   * @generated from field: repeated runme.parser.v1.Cell cells = 1;
   */
  cells?: CellJson[];
};

/**
 * Describes the message agent.v1.UpdateCellsRequest.
 * Use `create(UpdateCellsRequestSchema)` to create a new message.
 */
export declare const UpdateCellsRequestSchema: GenMessage<UpdateCellsRequest, {jsonType: UpdateCellsRequestJson}>;

/**
 * @generated from message agent.v1.UpdateCellsResponse
 */
export declare type UpdateCellsResponse = Message<"agent.v1.UpdateCellsResponse"> & {
  /**
   * We want to provide the updated cells to the AI because the cells might have been modified by
   * the agent (e.g. ref_ids) might have been generated.
   *
   * @generated from field: repeated runme.parser.v1.Cell cells = 1;
   */
  cells: Cell[];
};

/**
 * @generated from message agent.v1.UpdateCellsResponse
 */
export declare type UpdateCellsResponseJson = {
  /**
   * We want to provide the updated cells to the AI because the cells might have been modified by
   * the agent (e.g. ref_ids) might have been generated.
   *
   * @generated from field: repeated runme.parser.v1.Cell cells = 1;
   */
  cells?: CellJson[];
};

/**
 * Describes the message agent.v1.UpdateCellsResponse.
 * Use `create(UpdateCellsResponseSchema)` to create a new message.
 */
export declare const UpdateCellsResponseSchema: GenMessage<UpdateCellsResponse, {jsonType: UpdateCellsResponseJson}>;

/**
 * @generated from message agent.v1.NotebookServiceExecuteCellsRequest
 */
export declare type NotebookServiceExecuteCellsRequest = Message<"agent.v1.NotebookServiceExecuteCellsRequest"> & {
  /**
   * TODO(jlewi): Right now you the AI has to specify the IDs of the cells to execute. This means it
   * needs to use separate Update calls to set the code to execute. In the future, we may want to
   * allow the AISRE to issue a single execute request to update and execute.
   *
   * @generated from field: repeated string ref_ids = 1;
   */
  refIds: string[];
};

/**
 * @generated from message agent.v1.NotebookServiceExecuteCellsRequest
 */
export declare type NotebookServiceExecuteCellsRequestJson = {
  /**
   * TODO(jlewi): Right now you the AI has to specify the IDs of the cells to execute. This means it
   * needs to use separate Update calls to set the code to execute. In the future, we may want to
   * allow the AISRE to issue a single execute request to update and execute.
   *
   * @generated from field: repeated string ref_ids = 1;
   */
  refIds?: string[];
};

/**
 * Describes the message agent.v1.NotebookServiceExecuteCellsRequest.
 * Use `create(NotebookServiceExecuteCellsRequestSchema)` to create a new message.
 */
export declare const NotebookServiceExecuteCellsRequestSchema: GenMessage<NotebookServiceExecuteCellsRequest, {jsonType: NotebookServiceExecuteCellsRequestJson}>;

/**
 * @generated from message agent.v1.NotebookServiceExecuteCellsResponse
 */
export declare type NotebookServiceExecuteCellsResponse = Message<"agent.v1.NotebookServiceExecuteCellsResponse"> & {
  /**
   * Cells contains the cells that were executed
   *
   * @generated from field: repeated runme.parser.v1.Cell cells = 1;
   */
  cells: Cell[];
};

/**
 * @generated from message agent.v1.NotebookServiceExecuteCellsResponse
 */
export declare type NotebookServiceExecuteCellsResponseJson = {
  /**
   * Cells contains the cells that were executed
   *
   * @generated from field: repeated runme.parser.v1.Cell cells = 1;
   */
  cells?: CellJson[];
};

/**
 * Describes the message agent.v1.NotebookServiceExecuteCellsResponse.
 * Use `create(NotebookServiceExecuteCellsResponseSchema)` to create a new message.
 */
export declare const NotebookServiceExecuteCellsResponseSchema: GenMessage<NotebookServiceExecuteCellsResponse, {jsonType: NotebookServiceExecuteCellsResponseJson}>;

/**
 * @generated from message agent.v1.TerminateRunRequest
 */
export declare type TerminateRunRequest = Message<"agent.v1.TerminateRunRequest"> & {
};

/**
 * @generated from message agent.v1.TerminateRunRequest
 */
export declare type TerminateRunRequestJson = {
};

/**
 * Describes the message agent.v1.TerminateRunRequest.
 * Use `create(TerminateRunRequestSchema)` to create a new message.
 */
export declare const TerminateRunRequestSchema: GenMessage<TerminateRunRequest, {jsonType: TerminateRunRequestJson}>;

/**
 * @generated from message agent.v1.TerminateRunResponse
 */
export declare type TerminateRunResponse = Message<"agent.v1.TerminateRunResponse"> & {
};

/**
 * @generated from message agent.v1.TerminateRunResponse
 */
export declare type TerminateRunResponseJson = {
};

/**
 * Describes the message agent.v1.TerminateRunResponse.
 * Use `create(TerminateRunResponseSchema)` to create a new message.
 */
export declare const TerminateRunResponseSchema: GenMessage<TerminateRunResponse, {jsonType: TerminateRunResponseJson}>;

/**
 * ToolCallInput/ToolCallOutput are used by the backend to send/receive toolcalls from chatkit.
 * We bundle in the call_id and previous_response_id and send them to the client
 * so that the client can send them back.
 *
 * While "call_id" is part of ClientToolCallItem in chatkit's data model it doesn't seem to get
 * passed around on the client and back to the server so we handle it ourselves.
 *
 * @generated from message agent.v1.ToolCallInput
 */
export declare type ToolCallInput = Message<"agent.v1.ToolCallInput"> & {
  /**
   * @generated from field: string call_id = 1;
   */
  callId: string;

  /**
   * @generated from field: string previous_response_id = 2;
   */
  previousResponseId: string;

  /**
   * @generated from oneof agent.v1.ToolCallInput.input
   */
  input: {
    /**
     * @generated from field: agent.v1.UpdateCellsRequest update_cells = 3;
     */
    value: UpdateCellsRequest;
    case: "updateCells";
  } | {
    /**
     * @generated from field: agent.v1.ListCellsRequest list_cells = 4;
     */
    value: ListCellsRequest;
    case: "listCells";
  } | {
    /**
     * @generated from field: agent.v1.GetCellsRequest get_cells = 5;
     */
    value: GetCellsRequest;
    case: "getCells";
  } | {
    /**
     * @generated from field: agent.v1.NotebookServiceExecuteCellsRequest execute_cells = 6;
     */
    value: NotebookServiceExecuteCellsRequest;
    case: "executeCells";
  } | {
    /**
     * @generated from field: agent.v1.TerminateRunRequest terminate_run = 7;
     */
    value: TerminateRunRequest;
    case: "terminateRun";
  } | {
    /**
     * @generated from field: agent.v1.SendSlackMessageRequest send_slack_message = 8;
     */
    value: SendSlackMessageRequest;
    case: "sendSlackMessage";
  } | { case: undefined; value?: undefined };
};

/**
 * ToolCallInput/ToolCallOutput are used by the backend to send/receive toolcalls from chatkit.
 * We bundle in the call_id and previous_response_id and send them to the client
 * so that the client can send them back.
 *
 * While "call_id" is part of ClientToolCallItem in chatkit's data model it doesn't seem to get
 * passed around on the client and back to the server so we handle it ourselves.
 *
 * @generated from message agent.v1.ToolCallInput
 */
export declare type ToolCallInputJson = {
  /**
   * @generated from field: string call_id = 1;
   */
  callId?: string;

  /**
   * @generated from field: string previous_response_id = 2;
   */
  previousResponseId?: string;

  /**
   * @generated from field: agent.v1.UpdateCellsRequest update_cells = 3;
   */
  updateCells?: UpdateCellsRequestJson;

  /**
   * @generated from field: agent.v1.ListCellsRequest list_cells = 4;
   */
  listCells?: ListCellsRequestJson;

  /**
   * @generated from field: agent.v1.GetCellsRequest get_cells = 5;
   */
  getCells?: GetCellsRequestJson;

  /**
   * @generated from field: agent.v1.NotebookServiceExecuteCellsRequest execute_cells = 6;
   */
  executeCells?: NotebookServiceExecuteCellsRequestJson;

  /**
   * @generated from field: agent.v1.TerminateRunRequest terminate_run = 7;
   */
  terminateRun?: TerminateRunRequestJson;

  /**
   * @generated from field: agent.v1.SendSlackMessageRequest send_slack_message = 8;
   */
  sendSlackMessage?: SendSlackMessageRequestJson;
};

/**
 * Describes the message agent.v1.ToolCallInput.
 * Use `create(ToolCallInputSchema)` to create a new message.
 */
export declare const ToolCallInputSchema: GenMessage<ToolCallInput, {jsonType: ToolCallInputJson}>;

/**
 * @generated from message agent.v1.ToolCallOutput
 */
export declare type ToolCallOutput = Message<"agent.v1.ToolCallOutput"> & {
  /**
   * @generated from field: string call_id = 1;
   */
  callId: string;

  /**
   * @generated from field: string previous_response_id = 2;
   */
  previousResponseId: string;

  /**
   * @generated from oneof agent.v1.ToolCallOutput.output
   */
  output: {
    /**
     * @generated from field: agent.v1.UpdateCellsResponse update_cells = 3;
     */
    value: UpdateCellsResponse;
    case: "updateCells";
  } | {
    /**
     * @generated from field: agent.v1.ListCellsResponse list_cells = 4;
     */
    value: ListCellsResponse;
    case: "listCells";
  } | {
    /**
     * @generated from field: agent.v1.GetCellsResponse get_cells = 5;
     */
    value: GetCellsResponse;
    case: "getCells";
  } | {
    /**
     * @generated from field: agent.v1.NotebookServiceExecuteCellsResponse execute_cells = 8;
     */
    value: NotebookServiceExecuteCellsResponse;
    case: "executeCells";
  } | {
    /**
     * @generated from field: agent.v1.TerminateRunResponse terminate_run = 9;
     */
    value: TerminateRunResponse;
    case: "terminateRun";
  } | {
    /**
     * @generated from field: agent.v1.SendSlackMessageResponse send_slack_message = 10;
     */
    value: SendSlackMessageResponse;
    case: "sendSlackMessage";
  } | { case: undefined; value?: undefined };

  /**
   * @generated from field: agent.v1.ToolCallOutput.Status status = 6;
   */
  status: ToolCallOutput_Status;

  /**
   * client_error will be an error message if the client had one.
   *
   * @generated from field: string client_error = 7;
   */
  clientError: string;
};

/**
 * @generated from message agent.v1.ToolCallOutput
 */
export declare type ToolCallOutputJson = {
  /**
   * @generated from field: string call_id = 1;
   */
  callId?: string;

  /**
   * @generated from field: string previous_response_id = 2;
   */
  previousResponseId?: string;

  /**
   * @generated from field: agent.v1.UpdateCellsResponse update_cells = 3;
   */
  updateCells?: UpdateCellsResponseJson;

  /**
   * @generated from field: agent.v1.ListCellsResponse list_cells = 4;
   */
  listCells?: ListCellsResponseJson;

  /**
   * @generated from field: agent.v1.GetCellsResponse get_cells = 5;
   */
  getCells?: GetCellsResponseJson;

  /**
   * @generated from field: agent.v1.NotebookServiceExecuteCellsResponse execute_cells = 8;
   */
  executeCells?: NotebookServiceExecuteCellsResponseJson;

  /**
   * @generated from field: agent.v1.TerminateRunResponse terminate_run = 9;
   */
  terminateRun?: TerminateRunResponseJson;

  /**
   * @generated from field: agent.v1.SendSlackMessageResponse send_slack_message = 10;
   */
  sendSlackMessage?: SendSlackMessageResponseJson;

  /**
   * @generated from field: agent.v1.ToolCallOutput.Status status = 6;
   */
  status?: ToolCallOutput_StatusJson;

  /**
   * client_error will be an error message if the client had one.
   *
   * @generated from field: string client_error = 7;
   */
  clientError?: string;
};

/**
 * Describes the message agent.v1.ToolCallOutput.
 * Use `create(ToolCallOutputSchema)` to create a new message.
 */
export declare const ToolCallOutputSchema: GenMessage<ToolCallOutput, {jsonType: ToolCallOutputJson}>;

/**
 * @generated from enum agent.v1.ToolCallOutput.Status
 */
export enum ToolCallOutput_Status {
  /**
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: STATUS_SUCCESS = 1;
   */
  SUCCESS = 1,

  /**
   * @generated from enum value: STATUS_FAILED = 2;
   */
  FAILED = 2,
}

/**
 * @generated from enum agent.v1.ToolCallOutput.Status
 */
export declare type ToolCallOutput_StatusJson = "STATUS_UNSPECIFIED" | "STATUS_SUCCESS" | "STATUS_FAILED";

/**
 * Describes the enum agent.v1.ToolCallOutput.Status.
 */
export declare const ToolCallOutput_StatusSchema: GenEnum<ToolCallOutput_Status, ToolCallOutput_StatusJson>;

/**
 * ChatkitState is used by the backend to pass state back to chatkit.
 * This avoids needing to store state on the backend because we can just have the client store it.
 *
 * @generated from message agent.v1.ChatkitState
 */
export declare type ChatkitState = Message<"agent.v1.ChatkitState"> & {
  /**
   * @generated from field: string previous_response_id = 1;
   */
  previousResponseId: string;

  /**
   * @generated from field: string thread_id = 2;
   */
  threadId: string;
};

/**
 * ChatkitState is used by the backend to pass state back to chatkit.
 * This avoids needing to store state on the backend because we can just have the client store it.
 *
 * @generated from message agent.v1.ChatkitState
 */
export declare type ChatkitStateJson = {
  /**
   * @generated from field: string previous_response_id = 1;
   */
  previousResponseId?: string;

  /**
   * @generated from field: string thread_id = 2;
   */
  threadId?: string;
};

/**
 * Describes the message agent.v1.ChatkitState.
 * Use `create(ChatkitStateSchema)` to create a new message.
 */
export declare const ChatkitStateSchema: GenMessage<ChatkitState, {jsonType: ChatkitStateJson}>;

/**
 * @generated from message agent.v1.SendSlackMessageRequest
 */
export declare type SendSlackMessageRequest = Message<"agent.v1.SendSlackMessageRequest"> & {
  /**
   * @generated from field: string channel = 1;
   */
  channel: string;

  /**
   * @generated from field: string timestamp = 2;
   */
  timestamp: string;

  /**
   * @generated from field: string text = 3;
   */
  text: string;

  /**
   * @generated from field: repeated string file_ids = 4;
   */
  fileIds: string[];
};

/**
 * @generated from message agent.v1.SendSlackMessageRequest
 */
export declare type SendSlackMessageRequestJson = {
  /**
   * @generated from field: string channel = 1;
   */
  channel?: string;

  /**
   * @generated from field: string timestamp = 2;
   */
  timestamp?: string;

  /**
   * @generated from field: string text = 3;
   */
  text?: string;

  /**
   * @generated from field: repeated string file_ids = 4;
   */
  fileIds?: string[];
};

/**
 * Describes the message agent.v1.SendSlackMessageRequest.
 * Use `create(SendSlackMessageRequestSchema)` to create a new message.
 */
export declare const SendSlackMessageRequestSchema: GenMessage<SendSlackMessageRequest, {jsonType: SendSlackMessageRequestJson}>;

/**
 * @generated from message agent.v1.SendSlackMessageResponse
 */
export declare type SendSlackMessageResponse = Message<"agent.v1.SendSlackMessageResponse"> & {
  /**
   * The error if there is one
   *
   * @generated from field: string error = 1;
   */
  error: string;
};

/**
 * @generated from message agent.v1.SendSlackMessageResponse
 */
export declare type SendSlackMessageResponseJson = {
  /**
   * The error if there is one
   *
   * @generated from field: string error = 1;
   */
  error?: string;
};

/**
 * Describes the message agent.v1.SendSlackMessageResponse.
 * Use `create(SendSlackMessageResponseSchema)` to create a new message.
 */
export declare const SendSlackMessageResponseSchema: GenMessage<SendSlackMessageResponse, {jsonType: SendSlackMessageResponseJson}>;

/**
 * NotebookService defines methods the AI can use to interact with the notebook.
 * This is used to generate JSON schemas that can be used to define tool calls (or potentially) MCP
 * server. Using https://github.com/redpanda-data/protoc-gen-go-mcp.
 *
 * use the script project/aisre/toolsgen/build.sh to build the go code with the JSONSchemas.
 *
 * It looks like only comments on the method get translated into the description.
 *
 * TODO(jlewi): We should make it UpdateCells to allow the model to update multiple cells in a
 * single call.
 *
 * @generated from service agent.v1.NotebookService
 */
export declare const NotebookService: GenService<{
  /**
   * UpdateCell updates a cell in the document.
   * Cell is the cell to create or update. To update
   * an existing cell specify the ID of that cell in the ref_id field.
   * To create a new cell leave ref_id blank.
   *
   * You can use cell.metadata["agent/summary"] to include a short summary or description of the
   * cell. You should set the description so that its useful for deciding what cells you should read
   * to answer the user's queries.
   *
   * UpdateCellResponse will include cell id and metadata of the updated cells.
   *
   * @generated from rpc agent.v1.NotebookService.UpdateCells
   */
  updateCells: {
    methodKind: "unary";
    input: typeof UpdateCellsRequestSchema;
    output: typeof UpdateCellsResponseSchema;
  },
  /**
   * GetCells fetches the cells with the given ref_ids.
   * Use this to read the contents of cells in the notebook.
   *
   * @generated from rpc agent.v1.NotebookService.GetCells
   */
  getCells: {
    methodKind: "unary";
    input: typeof GetCellsRequestSchema;
    output: typeof GetCellsResponseSchema;
  },
  /**
   * ListCells lists the cells in a notebook.
   * Important: Only the ref_id and metadata will be populated. You should use that to decide
   * which cells to read.
   *
   * @generated from rpc agent.v1.NotebookService.ListCells
   */
  listCells: {
    methodKind: "unary";
    input: typeof ListCellsRequestSchema;
    output: typeof ListCellsResponseSchema;
  },
  /**
   * ExecuteCells executes the cells with the given ids in a notebook.
   * Use UpdateCells to write commands you want to execute then call ExecuteCells to execute the
   * cells. The response will contain the cell including the outputs of execution.
   *
   * @generated from rpc agent.v1.NotebookService.ExecuteCells
   */
  executeCells: {
    methodKind: "unary";
    input: typeof NotebookServiceExecuteCellsRequestSchema;
    output: typeof NotebookServiceExecuteCellsResponseSchema;
  },
  /**
   * TerminateRun terminates the run. Call this when no further processing is necessary to handle
   * the user request.
   *
   * @generated from rpc agent.v1.NotebookService.TerminateRun
   */
  terminateRun: {
    methodKind: "unary";
    input: typeof TerminateRunRequestSchema;
    output: typeof TerminateRunResponseSchema;
  },
}>;

