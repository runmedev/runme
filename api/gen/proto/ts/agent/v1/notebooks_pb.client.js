/* eslint-disable */
// @generated by protobuf-ts 2.11.1 with parameter output_javascript,optimize_code_size,long_type_string,add_pb_suffix,ts_nocheck,eslint_disable
// @generated from protobuf file "agent/v1/notebooks.proto" (package "agent.v1", syntax proto3)
// tslint:disable
// @ts-nocheck
import { NotebookService } from "./notebooks_pb";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
/**
 * NotebookService defines methods the AI can use to interact with the notebook.
 * This is used to generate JSON schemas that can be used to define tool calls (or potentially) MCP
 * server. Using https://github.com/redpanda-data/protoc-gen-go-mcp.
 *
 * use the script project/aisre/toolsgen/build.sh to build the go code with the JSONSchemas.
 *
 * It looks like only comments on the method get translated into the description.
 *
 * TODO(jlewi): We should make it UpdateCells to allow the model to update multiple cells in a
 * single call.
 *
 * @generated from protobuf service agent.v1.NotebookService
 */
export class NotebookServiceClient {
    constructor(_transport) {
        this._transport = _transport;
        this.typeName = NotebookService.typeName;
        this.methods = NotebookService.methods;
        this.options = NotebookService.options;
    }
    /**
     * UpdateCell updates a cell in the document.
     * Cell is the cell to create or update. To update
     * an existing cell specify the ID of that cell in the ref_id field.
     * To create a new cell leave ref_id blank.
     *
     * You can use cell.metadata["agent/summary"] to include a short summary or description of the
     * cell. You should set the description so that its useful for deciding what cells you should read
     * to answer the user's queries.
     *
     * UpdateCellResponse will include cell id and metadata of the updated cells.
     *
     * @generated from protobuf rpc: UpdateCells
     */
    updateCells(input, options) {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * GetCells fetches the cells with the given ref_ids.
     * Use this to read the contents of cells in the notebook.
     *
     * @generated from protobuf rpc: GetCells
     */
    getCells(input, options) {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * ListCells lists the cells in a notebook.
     * Important: Only the ref_id and metadata will be populated. You should use that to decide
     * which cells to read.
     *
     * @generated from protobuf rpc: ListCells
     */
    listCells(input, options) {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * ExecuteCells executes the cells with the given ids in a notebook.
     * Use UpdateCells to write commands you want to execute then call ExecuteCells to execute the
     * cells. The response will contain the cell including the outputs of execution.
     *
     * @generated from protobuf rpc: ExecuteCells
     */
    executeCells(input, options) {
        const method = this.methods[3], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * TerminateRun terminates the run. Call this when no further processing is necessary to handle
     * the user request.
     *
     * @generated from protobuf rpc: TerminateRun
     */
    terminateRun(input, options) {
        const method = this.methods[4], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
}
