/* eslint-disable */
// @generated by protobuf-ts 2.11.1 with parameter output_javascript,optimize_code_size,long_type_string,add_pb_suffix,ts_nocheck,eslint_disable
// @generated from protobuf file "agent/v1/notebooks.proto" (package "agent.v1", syntax proto3)
// tslint:disable
// @ts-nocheck
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import type { TerminateRunResponse } from "./notebooks_pb";
import type { TerminateRunRequest } from "./notebooks_pb";
import type { NotebookServiceExecuteCellsResponse } from "./notebooks_pb";
import type { NotebookServiceExecuteCellsRequest } from "./notebooks_pb";
import type { ListCellsResponse } from "./notebooks_pb";
import type { ListCellsRequest } from "./notebooks_pb";
import type { GetCellsResponse } from "./notebooks_pb";
import type { GetCellsRequest } from "./notebooks_pb";
import type { UpdateCellsResponse } from "./notebooks_pb";
import type { UpdateCellsRequest } from "./notebooks_pb";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * NotebookService defines methods the AI can use to interact with the notebook.
 * This is used to generate JSON schemas that can be used to define tool calls (or potentially) MCP
 * server. Using https://github.com/redpanda-data/protoc-gen-go-mcp.
 *
 * use the script project/aisre/toolsgen/build.sh to build the go code with the JSONSchemas.
 *
 * It looks like only comments on the method get translated into the description.
 *
 * TODO(jlewi): We should make it UpdateCells to allow the model to update multiple cells in a
 * single call.
 *
 * @generated from protobuf service agent.v1.NotebookService
 */
export interface INotebookServiceClient {
    /**
     * UpdateCell updates a cell in the document.
     * Cell is the cell to create or update. To update
     * an existing cell specify the ID of that cell in the ref_id field.
     * To create a new cell leave ref_id blank.
     *
     * You can use cell.metadata["agent/summary"] to include a short summary or description of the
     * cell. You should set the description so that its useful for deciding what cells you should read
     * to answer the user's queries.
     *
     * UpdateCellResponse will include cell id and metadata of the updated cells.
     *
     * @generated from protobuf rpc: UpdateCells
     */
    updateCells(input: UpdateCellsRequest, options?: RpcOptions): UnaryCall<UpdateCellsRequest, UpdateCellsResponse>;
    /**
     * GetCells fetches the cells with the given ref_ids.
     * Use this to read the contents of cells in the notebook.
     *
     * @generated from protobuf rpc: GetCells
     */
    getCells(input: GetCellsRequest, options?: RpcOptions): UnaryCall<GetCellsRequest, GetCellsResponse>;
    /**
     * ListCells lists the cells in a notebook.
     * Important: Only the ref_id and metadata will be populated. You should use that to decide
     * which cells to read.
     *
     * @generated from protobuf rpc: ListCells
     */
    listCells(input: ListCellsRequest, options?: RpcOptions): UnaryCall<ListCellsRequest, ListCellsResponse>;
    /**
     * ExecuteCells executes the cells with the given ids in a notebook.
     * Use UpdateCells to write commands you want to execute then call ExecuteCells to execute the
     * cells. The response will contain the cell including the outputs of execution.
     *
     * @generated from protobuf rpc: ExecuteCells
     */
    executeCells(input: NotebookServiceExecuteCellsRequest, options?: RpcOptions): UnaryCall<NotebookServiceExecuteCellsRequest, NotebookServiceExecuteCellsResponse>;
    /**
     * TerminateRun terminates the run. Call this when no further processing is necessary to handle
     * the user request.
     *
     * @generated from protobuf rpc: TerminateRun
     */
    terminateRun(input: TerminateRunRequest, options?: RpcOptions): UnaryCall<TerminateRunRequest, TerminateRunResponse>;
}
/**
 * NotebookService defines methods the AI can use to interact with the notebook.
 * This is used to generate JSON schemas that can be used to define tool calls (or potentially) MCP
 * server. Using https://github.com/redpanda-data/protoc-gen-go-mcp.
 *
 * use the script project/aisre/toolsgen/build.sh to build the go code with the JSONSchemas.
 *
 * It looks like only comments on the method get translated into the description.
 *
 * TODO(jlewi): We should make it UpdateCells to allow the model to update multiple cells in a
 * single call.
 *
 * @generated from protobuf service agent.v1.NotebookService
 */
export declare class NotebookServiceClient implements INotebookServiceClient, ServiceInfo {
    private readonly _transport;
    typeName: any;
    methods: any;
    options: any;
    constructor(_transport: RpcTransport);
    /**
     * UpdateCell updates a cell in the document.
     * Cell is the cell to create or update. To update
     * an existing cell specify the ID of that cell in the ref_id field.
     * To create a new cell leave ref_id blank.
     *
     * You can use cell.metadata["agent/summary"] to include a short summary or description of the
     * cell. You should set the description so that its useful for deciding what cells you should read
     * to answer the user's queries.
     *
     * UpdateCellResponse will include cell id and metadata of the updated cells.
     *
     * @generated from protobuf rpc: UpdateCells
     */
    updateCells(input: UpdateCellsRequest, options?: RpcOptions): UnaryCall<UpdateCellsRequest, UpdateCellsResponse>;
    /**
     * GetCells fetches the cells with the given ref_ids.
     * Use this to read the contents of cells in the notebook.
     *
     * @generated from protobuf rpc: GetCells
     */
    getCells(input: GetCellsRequest, options?: RpcOptions): UnaryCall<GetCellsRequest, GetCellsResponse>;
    /**
     * ListCells lists the cells in a notebook.
     * Important: Only the ref_id and metadata will be populated. You should use that to decide
     * which cells to read.
     *
     * @generated from protobuf rpc: ListCells
     */
    listCells(input: ListCellsRequest, options?: RpcOptions): UnaryCall<ListCellsRequest, ListCellsResponse>;
    /**
     * ExecuteCells executes the cells with the given ids in a notebook.
     * Use UpdateCells to write commands you want to execute then call ExecuteCells to execute the
     * cells. The response will contain the cell including the outputs of execution.
     *
     * @generated from protobuf rpc: ExecuteCells
     */
    executeCells(input: NotebookServiceExecuteCellsRequest, options?: RpcOptions): UnaryCall<NotebookServiceExecuteCellsRequest, NotebookServiceExecuteCellsResponse>;
    /**
     * TerminateRun terminates the run. Call this when no further processing is necessary to handle
     * the user request.
     *
     * @generated from protobuf rpc: TerminateRun
     */
    terminateRun(input: TerminateRunRequest, options?: RpcOptions): UnaryCall<TerminateRunRequest, TerminateRunResponse>;
}
