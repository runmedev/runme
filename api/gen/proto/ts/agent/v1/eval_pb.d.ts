/* eslint-disable */
// @generated by protobuf-ts 2.11.1 with parameter output_javascript,optimize_code_size,long_type_string,add_pb_suffix,ts_nocheck,eslint_disable
// @generated from protobuf file "agent/v1/eval.proto" (package "agent.v1", syntax proto3)
// tslint:disable
// @ts-nocheck
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * -------------------------------------------------------------------------
 * Assertions
 * -------------------------------------------------------------------------
 *
 * @generated from protobuf message agent.v1.Assertion
 */
export interface Assertion {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * @generated from protobuf field: agent.v1.Assertion.Type type = 2
     */
    type: Assertion_Type;
    /**
     * @generated from protobuf field: agent.v1.Assertion.Result result = 3
     */
    result: Assertion_Result;
    /**
     * Exactly one concrete assertion payload must be present.
     *
     * @generated from protobuf oneof: payload
     */
    payload: {
        oneofKind: "shellRequiredFlag";
        /**
         * @generated from protobuf field: agent.v1.Assertion.ShellRequiredFlag shell_required_flag = 4
         */
        shellRequiredFlag: Assertion_ShellRequiredFlag;
    } | {
        oneofKind: "toolInvocation";
        /**
         * @generated from protobuf field: agent.v1.Assertion.ToolInvocation tool_invocation = 5
         */
        toolInvocation: Assertion_ToolInvocation;
    } | {
        oneofKind: "fileRetrieval";
        /**
         * @generated from protobuf field: agent.v1.Assertion.FileRetrieval file_retrieval = 6
         */
        fileRetrieval: Assertion_FileRetrieval;
    } | {
        oneofKind: "llmJudge";
        /**
         * @generated from protobuf field: agent.v1.Assertion.LLMJudge llm_judge = 7
         */
        llmJudge: Assertion_LLMJudge;
    } | {
        oneofKind: "codeblockRegex";
        /**
         * @generated from protobuf field: agent.v1.Assertion.CodeblockRegex codeblock_regex = 8
         */
        codeblockRegex: Assertion_CodeblockRegex;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: string failure_reason = 9
     */
    failureReason: string;
}
/**
 * Verifies that a shell command includes specific flags.
 *
 * @generated from protobuf message agent.v1.Assertion.ShellRequiredFlag
 */
export interface Assertion_ShellRequiredFlag {
    /**
     * @generated from protobuf field: string command = 1
     */
    command: string;
    /**
     * @generated from protobuf field: repeated string flags = 2
     */
    flags: string[];
}
/**
 * Verifies that a tool **is** or **is not** invoked.
 *
 * @generated from protobuf message agent.v1.Assertion.ToolInvocation
 */
export interface Assertion_ToolInvocation {
    /**
     * @generated from protobuf field: string tool_name = 1
     */
    toolName: string;
}
/**
 * Verifies that a file **is** or **is not** retrieved.
 *
 * @generated from protobuf message agent.v1.Assertion.FileRetrieval
 */
export interface Assertion_FileRetrieval {
    /**
     * @generated from protobuf field: string file_id = 1
     */
    fileId: string;
    /**
     * @generated from protobuf field: string file_name = 2
     */
    fileName: string;
}
/**
 * Asks an LLM to grade the assistant's answer.
 *
 * @generated from protobuf message agent.v1.Assertion.LLMJudge
 */
export interface Assertion_LLMJudge {
    /**
     * @generated from protobuf field: string prompt = 1
     */
    prompt: string;
}
/**
 * Checks if at least one code block matches the regex.
 *
 * @generated from protobuf message agent.v1.Assertion.CodeblockRegex
 */
export interface Assertion_CodeblockRegex {
    /**
     * @generated from protobuf field: string regex = 1
     */
    regex: string;
}
/**
 * What we are checking for.
 *
 * @generated from protobuf enum agent.v1.Assertion.Type
 */
export declare enum Assertion_Type {
    /**
     * @generated from protobuf enum value: TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Were all required CLI flags present?
     *
     * @generated from protobuf enum value: TYPE_SHELL_REQUIRED_FLAG = 1;
     */
    SHELL_REQUIRED_FLAG = 1,
    /**
     * Was a tool invoked (or not)?
     *
     * @generated from protobuf enum value: TYPE_TOOL_INVOKED = 2;
     */
    TOOL_INVOKED = 2,
    /**
     * Was a file retrieved (or not)?
     *
     * @generated from protobuf enum value: TYPE_FILE_RETRIEVED = 3;
     */
    FILE_RETRIEVED = 3,
    /**
     * Ask an LLM to grade the final answer.
     *
     * @generated from protobuf enum value: TYPE_LLM_JUDGE = 4;
     */
    LLM_JUDGE = 4,
    /**
     * Does at least one code block match the regex?
     *
     * @generated from protobuf enum value: TYPE_CODEBLOCK_REGEX = 5;
     */
    CODEBLOCK_REGEX = 5
}
/**
 * Outcome of an assertion after a test run.
 *
 * @generated from protobuf enum agent.v1.Assertion.Result
 */
export declare enum Assertion_Result {
    /**
     * @generated from protobuf enum value: RESULT_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: RESULT_TRUE = 1;
     */
    TRUE = 1,
    /**
     * @generated from protobuf enum value: RESULT_FALSE = 2;
     */
    FALSE = 2,
    /**
     * @generated from protobuf enum value: RESULT_SKIPPED = 3;
     */
    SKIPPED = 3
}
/**
 * -------------------------------------------------------------------------
 * EvalSample â€“ Represents a single evaluation input and its expected assertions
 * -------------------------------------------------------------------------
 *
 * @generated from protobuf message agent.v1.EvalSample
 */
export interface EvalSample {
    /**
     * @generated from protobuf field: string kind = 1
     */
    kind: string;
    /**
     * @generated from protobuf field: agent.v1.ObjectMeta metadata = 2
     */
    metadata?: ObjectMeta;
    /**
     * @generated from protobuf field: string input_text = 3
     */
    inputText: string;
    /**
     * @generated from protobuf field: repeated agent.v1.Assertion assertions = 4
     */
    assertions: Assertion[];
}
/**
 * @generated from protobuf message agent.v1.EvalDataset
 */
export interface EvalDataset {
    /**
     * @generated from protobuf field: repeated agent.v1.EvalSample samples = 1
     */
    samples: EvalSample[];
}
/**
 * @generated from protobuf message agent.v1.ObjectMeta
 */
export interface ObjectMeta {
    /**
     * Name of the resource, e.g. "experiment-test".
     *
     * @generated from protobuf field: string name = 1
     */
    name: string;
}
/**
 * @generated from protobuf message agent.v1.ExperimentSpec
 */
export interface ExperimentSpec {
    /**
     * Path to the folder containing the dataset to evaluate.
     *
     * @generated from protobuf field: string dataset_path = 1
     */
    datasetPath: string;
    /**
     * Directory where experiment reports will be written.
     *
     * @generated from protobuf field: string output_dir = 2
     */
    outputDir: string;
    /**
     * URL of the backend inference service to call during evaluation.
     *
     * @generated from protobuf field: string inference_endpoint = 3
     */
    inferenceEndpoint: string;
}
/**
 * @generated from protobuf message agent.v1.Experiment
 */
export interface Experiment {
    /**
     * API version of the resource, e.g. "cloudassistant.io/v1alpha1".
     *
     * @generated from protobuf field: string api_version = 1
     */
    apiVersion: string;
    /**
     * Kind of the resource. Always "Experiment" for this CRD.
     *
     * @generated from protobuf field: string kind = 2
     */
    kind: string;
    /**
     * Standard Kubernetes object metadata (name, labels, annotations, etc.).
     *
     * @generated from protobuf field: agent.v1.ObjectMeta metadata = 3
     */
    metadata?: ObjectMeta;
    /**
     * User-defined configuration for the experiment.
     *
     * @generated from protobuf field: agent.v1.ExperimentSpec spec = 4
     */
    spec?: ExperimentSpec;
}
declare class Assertion$Type extends MessageType<Assertion> {
    constructor();
    create(value?: PartialMessage<Assertion>): Assertion;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Assertion): Assertion;
    internalBinaryWrite(message: Assertion, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message agent.v1.Assertion
 */
export declare const Assertion: Assertion$Type;
declare class Assertion_ShellRequiredFlag$Type extends MessageType<Assertion_ShellRequiredFlag> {
    constructor();
    create(value?: PartialMessage<Assertion_ShellRequiredFlag>): Assertion_ShellRequiredFlag;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Assertion_ShellRequiredFlag): Assertion_ShellRequiredFlag;
    internalBinaryWrite(message: Assertion_ShellRequiredFlag, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message agent.v1.Assertion.ShellRequiredFlag
 */
export declare const Assertion_ShellRequiredFlag: Assertion_ShellRequiredFlag$Type;
declare class Assertion_ToolInvocation$Type extends MessageType<Assertion_ToolInvocation> {
    constructor();
    create(value?: PartialMessage<Assertion_ToolInvocation>): Assertion_ToolInvocation;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Assertion_ToolInvocation): Assertion_ToolInvocation;
    internalBinaryWrite(message: Assertion_ToolInvocation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message agent.v1.Assertion.ToolInvocation
 */
export declare const Assertion_ToolInvocation: Assertion_ToolInvocation$Type;
declare class Assertion_FileRetrieval$Type extends MessageType<Assertion_FileRetrieval> {
    constructor();
    create(value?: PartialMessage<Assertion_FileRetrieval>): Assertion_FileRetrieval;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Assertion_FileRetrieval): Assertion_FileRetrieval;
    internalBinaryWrite(message: Assertion_FileRetrieval, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message agent.v1.Assertion.FileRetrieval
 */
export declare const Assertion_FileRetrieval: Assertion_FileRetrieval$Type;
declare class Assertion_LLMJudge$Type extends MessageType<Assertion_LLMJudge> {
    constructor();
    create(value?: PartialMessage<Assertion_LLMJudge>): Assertion_LLMJudge;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Assertion_LLMJudge): Assertion_LLMJudge;
    internalBinaryWrite(message: Assertion_LLMJudge, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message agent.v1.Assertion.LLMJudge
 */
export declare const Assertion_LLMJudge: Assertion_LLMJudge$Type;
declare class Assertion_CodeblockRegex$Type extends MessageType<Assertion_CodeblockRegex> {
    constructor();
    create(value?: PartialMessage<Assertion_CodeblockRegex>): Assertion_CodeblockRegex;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Assertion_CodeblockRegex): Assertion_CodeblockRegex;
    internalBinaryWrite(message: Assertion_CodeblockRegex, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message agent.v1.Assertion.CodeblockRegex
 */
export declare const Assertion_CodeblockRegex: Assertion_CodeblockRegex$Type;
declare class EvalSample$Type extends MessageType<EvalSample> {
    constructor();
    create(value?: PartialMessage<EvalSample>): EvalSample;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvalSample): EvalSample;
    internalBinaryWrite(message: EvalSample, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message agent.v1.EvalSample
 */
export declare const EvalSample: EvalSample$Type;
declare class EvalDataset$Type extends MessageType<EvalDataset> {
    constructor();
    create(value?: PartialMessage<EvalDataset>): EvalDataset;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvalDataset): EvalDataset;
    internalBinaryWrite(message: EvalDataset, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message agent.v1.EvalDataset
 */
export declare const EvalDataset: EvalDataset$Type;
declare class ObjectMeta$Type extends MessageType<ObjectMeta> {
    constructor();
    create(value?: PartialMessage<ObjectMeta>): ObjectMeta;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ObjectMeta): ObjectMeta;
    internalBinaryWrite(message: ObjectMeta, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message agent.v1.ObjectMeta
 */
export declare const ObjectMeta: ObjectMeta$Type;
declare class ExperimentSpec$Type extends MessageType<ExperimentSpec> {
    constructor();
    create(value?: PartialMessage<ExperimentSpec>): ExperimentSpec;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExperimentSpec): ExperimentSpec;
    internalBinaryWrite(message: ExperimentSpec, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message agent.v1.ExperimentSpec
 */
export declare const ExperimentSpec: ExperimentSpec$Type;
declare class Experiment$Type extends MessageType<Experiment> {
    constructor();
    create(value?: PartialMessage<Experiment>): Experiment;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment): Experiment;
    internalBinaryWrite(message: Experiment, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message agent.v1.Experiment
 */
export declare const Experiment: Experiment$Type;
export {};
