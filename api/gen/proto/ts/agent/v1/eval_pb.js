/* eslint-disable */
// @generated by protobuf-ts 2.11.1 with parameter output_javascript,optimize_code_size,long_type_string,add_pb_suffix,ts_nocheck,eslint_disable
// @generated from protobuf file "agent/v1/eval.proto" (package "agent.v1", syntax proto3)
// tslint:disable
// @ts-nocheck
import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * What we are checking for.
 *
 * @generated from protobuf enum agent.v1.Assertion.Type
 */
export var Assertion_Type;
(function (Assertion_Type) {
    /**
     * @generated from protobuf enum value: TYPE_UNSPECIFIED = 0;
     */
    Assertion_Type[Assertion_Type["UNSPECIFIED"] = 0] = "UNSPECIFIED";
    /**
     * Were all required CLI flags present?
     *
     * @generated from protobuf enum value: TYPE_SHELL_REQUIRED_FLAG = 1;
     */
    Assertion_Type[Assertion_Type["SHELL_REQUIRED_FLAG"] = 1] = "SHELL_REQUIRED_FLAG";
    /**
     * Was a tool invoked (or not)?
     *
     * @generated from protobuf enum value: TYPE_TOOL_INVOKED = 2;
     */
    Assertion_Type[Assertion_Type["TOOL_INVOKED"] = 2] = "TOOL_INVOKED";
    /**
     * Was a file retrieved (or not)?
     *
     * @generated from protobuf enum value: TYPE_FILE_RETRIEVED = 3;
     */
    Assertion_Type[Assertion_Type["FILE_RETRIEVED"] = 3] = "FILE_RETRIEVED";
    /**
     * Ask an LLM to grade the final answer.
     *
     * @generated from protobuf enum value: TYPE_LLM_JUDGE = 4;
     */
    Assertion_Type[Assertion_Type["LLM_JUDGE"] = 4] = "LLM_JUDGE";
    /**
     * Does at least one code block match the regex?
     *
     * @generated from protobuf enum value: TYPE_CODEBLOCK_REGEX = 5;
     */
    Assertion_Type[Assertion_Type["CODEBLOCK_REGEX"] = 5] = "CODEBLOCK_REGEX";
})(Assertion_Type || (Assertion_Type = {}));
/**
 * Outcome of an assertion after a test run.
 *
 * @generated from protobuf enum agent.v1.Assertion.Result
 */
export var Assertion_Result;
(function (Assertion_Result) {
    /**
     * @generated from protobuf enum value: RESULT_UNSPECIFIED = 0;
     */
    Assertion_Result[Assertion_Result["UNSPECIFIED"] = 0] = "UNSPECIFIED";
    /**
     * @generated from protobuf enum value: RESULT_TRUE = 1;
     */
    Assertion_Result[Assertion_Result["TRUE"] = 1] = "TRUE";
    /**
     * @generated from protobuf enum value: RESULT_FALSE = 2;
     */
    Assertion_Result[Assertion_Result["FALSE"] = 2] = "FALSE";
    /**
     * @generated from protobuf enum value: RESULT_SKIPPED = 3;
     */
    Assertion_Result[Assertion_Result["SKIPPED"] = 3] = "SKIPPED";
})(Assertion_Result || (Assertion_Result = {}));
// @generated message type with reflection information, may provide speed optimized methods
class Assertion$Type extends MessageType {
    constructor() {
        super("agent.v1.Assertion", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { required: true, string: { minLen: "1" } } } },
            { no: 2, name: "type", kind: "enum", T: () => ["agent.v1.Assertion.Type", Assertion_Type, "TYPE_"], options: { "buf.validate.field": { required: true } } },
            { no: 3, name: "result", kind: "enum", T: () => ["agent.v1.Assertion.Result", Assertion_Result, "RESULT_"] },
            { no: 4, name: "shell_required_flag", kind: "message", oneof: "payload", T: () => Assertion_ShellRequiredFlag },
            { no: 5, name: "tool_invocation", kind: "message", oneof: "payload", T: () => Assertion_ToolInvocation },
            { no: 6, name: "file_retrieval", kind: "message", oneof: "payload", T: () => Assertion_FileRetrieval },
            { no: 7, name: "llm_judge", kind: "message", oneof: "payload", T: () => Assertion_LLMJudge },
            { no: 8, name: "codeblock_regex", kind: "message", oneof: "payload", T: () => Assertion_CodeblockRegex },
            { no: 9, name: "failure_reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.name = "";
        message.type = 0;
        message.result = 0;
        message.payload = { oneofKind: undefined };
        message.failureReason = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* agent.v1.Assertion.Type type */ 2:
                    message.type = reader.int32();
                    break;
                case /* agent.v1.Assertion.Result result */ 3:
                    message.result = reader.int32();
                    break;
                case /* agent.v1.Assertion.ShellRequiredFlag shell_required_flag */ 4:
                    message.payload = {
                        oneofKind: "shellRequiredFlag",
                        shellRequiredFlag: Assertion_ShellRequiredFlag.internalBinaryRead(reader, reader.uint32(), options, message.payload.shellRequiredFlag)
                    };
                    break;
                case /* agent.v1.Assertion.ToolInvocation tool_invocation */ 5:
                    message.payload = {
                        oneofKind: "toolInvocation",
                        toolInvocation: Assertion_ToolInvocation.internalBinaryRead(reader, reader.uint32(), options, message.payload.toolInvocation)
                    };
                    break;
                case /* agent.v1.Assertion.FileRetrieval file_retrieval */ 6:
                    message.payload = {
                        oneofKind: "fileRetrieval",
                        fileRetrieval: Assertion_FileRetrieval.internalBinaryRead(reader, reader.uint32(), options, message.payload.fileRetrieval)
                    };
                    break;
                case /* agent.v1.Assertion.LLMJudge llm_judge */ 7:
                    message.payload = {
                        oneofKind: "llmJudge",
                        llmJudge: Assertion_LLMJudge.internalBinaryRead(reader, reader.uint32(), options, message.payload.llmJudge)
                    };
                    break;
                case /* agent.v1.Assertion.CodeblockRegex codeblock_regex */ 8:
                    message.payload = {
                        oneofKind: "codeblockRegex",
                        codeblockRegex: Assertion_CodeblockRegex.internalBinaryRead(reader, reader.uint32(), options, message.payload.codeblockRegex)
                    };
                    break;
                case /* string failure_reason */ 9:
                    message.failureReason = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* agent.v1.Assertion.Type type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* agent.v1.Assertion.Result result = 3; */
        if (message.result !== 0)
            writer.tag(3, WireType.Varint).int32(message.result);
        /* agent.v1.Assertion.ShellRequiredFlag shell_required_flag = 4; */
        if (message.payload.oneofKind === "shellRequiredFlag")
            Assertion_ShellRequiredFlag.internalBinaryWrite(message.payload.shellRequiredFlag, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* agent.v1.Assertion.ToolInvocation tool_invocation = 5; */
        if (message.payload.oneofKind === "toolInvocation")
            Assertion_ToolInvocation.internalBinaryWrite(message.payload.toolInvocation, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* agent.v1.Assertion.FileRetrieval file_retrieval = 6; */
        if (message.payload.oneofKind === "fileRetrieval")
            Assertion_FileRetrieval.internalBinaryWrite(message.payload.fileRetrieval, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* agent.v1.Assertion.LLMJudge llm_judge = 7; */
        if (message.payload.oneofKind === "llmJudge")
            Assertion_LLMJudge.internalBinaryWrite(message.payload.llmJudge, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* agent.v1.Assertion.CodeblockRegex codeblock_regex = 8; */
        if (message.payload.oneofKind === "codeblockRegex")
            Assertion_CodeblockRegex.internalBinaryWrite(message.payload.codeblockRegex, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* string failure_reason = 9; */
        if (message.failureReason !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.failureReason);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message agent.v1.Assertion
 */
export const Assertion = new Assertion$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Assertion_ShellRequiredFlag$Type extends MessageType {
    constructor() {
        super("agent.v1.Assertion.ShellRequiredFlag", [
            { no: 1, name: "command", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { required: true, string: { minLen: "1" } } } },
            { no: 2, name: "flags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { required: true, repeated: { minItems: "1" } } } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.command = "";
        message.flags = [];
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string command */ 1:
                    message.command = reader.string();
                    break;
                case /* repeated string flags */ 2:
                    message.flags.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string command = 1; */
        if (message.command !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.command);
        /* repeated string flags = 2; */
        for (let i = 0; i < message.flags.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.flags[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message agent.v1.Assertion.ShellRequiredFlag
 */
export const Assertion_ShellRequiredFlag = new Assertion_ShellRequiredFlag$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Assertion_ToolInvocation$Type extends MessageType {
    constructor() {
        super("agent.v1.Assertion.ToolInvocation", [
            { no: 1, name: "tool_name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { required: true, string: { minLen: "1" } } } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.toolName = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tool_name */ 1:
                    message.toolName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string tool_name = 1; */
        if (message.toolName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.toolName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message agent.v1.Assertion.ToolInvocation
 */
export const Assertion_ToolInvocation = new Assertion_ToolInvocation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Assertion_FileRetrieval$Type extends MessageType {
    constructor() {
        super("agent.v1.Assertion.FileRetrieval", [
            { no: 1, name: "file_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { required: true, string: { minLen: "1" } } } },
            { no: 2, name: "file_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.fileId = "";
        message.fileName = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string file_id */ 1:
                    message.fileId = reader.string();
                    break;
                case /* string file_name */ 2:
                    message.fileName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string file_id = 1; */
        if (message.fileId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.fileId);
        /* string file_name = 2; */
        if (message.fileName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.fileName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message agent.v1.Assertion.FileRetrieval
 */
export const Assertion_FileRetrieval = new Assertion_FileRetrieval$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Assertion_LLMJudge$Type extends MessageType {
    constructor() {
        super("agent.v1.Assertion.LLMJudge", [
            { no: 1, name: "prompt", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { required: true, string: { minLen: "1" } } } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.prompt = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string prompt */ 1:
                    message.prompt = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string prompt = 1; */
        if (message.prompt !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.prompt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message agent.v1.Assertion.LLMJudge
 */
export const Assertion_LLMJudge = new Assertion_LLMJudge$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Assertion_CodeblockRegex$Type extends MessageType {
    constructor() {
        super("agent.v1.Assertion.CodeblockRegex", [
            { no: 1, name: "regex", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { required: true, string: { minLen: "1" } } } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.regex = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string regex */ 1:
                    message.regex = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string regex = 1; */
        if (message.regex !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.regex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message agent.v1.Assertion.CodeblockRegex
 */
export const Assertion_CodeblockRegex = new Assertion_CodeblockRegex$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvalSample$Type extends MessageType {
    constructor() {
        super("agent.v1.EvalSample", [
            { no: 1, name: "kind", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { required: true, string: { minLen: "1" } } } },
            { no: 2, name: "metadata", kind: "message", T: () => ObjectMeta, options: { "buf.validate.field": { required: true } } },
            { no: 3, name: "input_text", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { required: true, string: { minLen: "1" } } } },
            { no: 4, name: "assertions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Assertion, options: { "buf.validate.field": { required: true, repeated: { minItems: "1" } } } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.kind = "";
        message.inputText = "";
        message.assertions = [];
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string kind */ 1:
                    message.kind = reader.string();
                    break;
                case /* agent.v1.ObjectMeta metadata */ 2:
                    message.metadata = ObjectMeta.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* string input_text */ 3:
                    message.inputText = reader.string();
                    break;
                case /* repeated agent.v1.Assertion assertions */ 4:
                    message.assertions.push(Assertion.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string kind = 1; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* agent.v1.ObjectMeta metadata = 2; */
        if (message.metadata)
            ObjectMeta.internalBinaryWrite(message.metadata, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string input_text = 3; */
        if (message.inputText !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.inputText);
        /* repeated agent.v1.Assertion assertions = 4; */
        for (let i = 0; i < message.assertions.length; i++)
            Assertion.internalBinaryWrite(message.assertions[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message agent.v1.EvalSample
 */
export const EvalSample = new EvalSample$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvalDataset$Type extends MessageType {
    constructor() {
        super("agent.v1.EvalDataset", [
            { no: 1, name: "samples", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => EvalSample }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.samples = [];
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated agent.v1.EvalSample samples */ 1:
                    message.samples.push(EvalSample.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated agent.v1.EvalSample samples = 1; */
        for (let i = 0; i < message.samples.length; i++)
            EvalSample.internalBinaryWrite(message.samples[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message agent.v1.EvalDataset
 */
export const EvalDataset = new EvalDataset$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ObjectMeta$Type extends MessageType {
    constructor() {
        super("agent.v1.ObjectMeta", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { required: true, string: { minLen: "1" } } } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message agent.v1.ObjectMeta
 */
export const ObjectMeta = new ObjectMeta$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExperimentSpec$Type extends MessageType {
    constructor() {
        super("agent.v1.ExperimentSpec", [
            { no: 1, name: "dataset_path", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { required: true, string: { minLen: "1" } } } },
            { no: 2, name: "output_dir", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { required: true, string: { minLen: "1" } } } },
            { no: 3, name: "inference_endpoint", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { required: true, string: { minLen: "1" } } } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.datasetPath = "";
        message.outputDir = "";
        message.inferenceEndpoint = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string dataset_path */ 1:
                    message.datasetPath = reader.string();
                    break;
                case /* string output_dir */ 2:
                    message.outputDir = reader.string();
                    break;
                case /* string inference_endpoint */ 3:
                    message.inferenceEndpoint = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string dataset_path = 1; */
        if (message.datasetPath !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.datasetPath);
        /* string output_dir = 2; */
        if (message.outputDir !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.outputDir);
        /* string inference_endpoint = 3; */
        if (message.inferenceEndpoint !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.inferenceEndpoint);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message agent.v1.ExperimentSpec
 */
export const ExperimentSpec = new ExperimentSpec$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment$Type extends MessageType {
    constructor() {
        super("agent.v1.Experiment", [
            { no: 1, name: "api_version", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { required: true, string: { minLen: "1" } } } },
            { no: 2, name: "kind", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { required: true, string: { minLen: "1" } } } },
            { no: 3, name: "metadata", kind: "message", T: () => ObjectMeta, options: { "buf.validate.field": { required: true } } },
            { no: 4, name: "spec", kind: "message", T: () => ExperimentSpec, options: { "buf.validate.field": { required: true } } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.apiVersion = "";
        message.kind = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string api_version */ 1:
                    message.apiVersion = reader.string();
                    break;
                case /* string kind */ 2:
                    message.kind = reader.string();
                    break;
                case /* agent.v1.ObjectMeta metadata */ 3:
                    message.metadata = ObjectMeta.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* agent.v1.ExperimentSpec spec */ 4:
                    message.spec = ExperimentSpec.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string api_version = 1; */
        if (message.apiVersion !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.apiVersion);
        /* string kind = 2; */
        if (message.kind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.kind);
        /* agent.v1.ObjectMeta metadata = 3; */
        if (message.metadata)
            ObjectMeta.internalBinaryWrite(message.metadata, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* agent.v1.ExperimentSpec spec = 4; */
        if (message.spec)
            ExperimentSpec.internalBinaryWrite(message.spec, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message agent.v1.Experiment
 */
export const Experiment = new Experiment$Type();
