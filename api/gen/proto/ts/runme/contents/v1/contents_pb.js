/* eslint-disable */
// @generated by protobuf-ts 2.11.1 with parameter output_javascript,optimize_code_size,long_type_string,add_pb_suffix,ts_nocheck,eslint_disable
// @generated from protobuf file "runme/contents/v1/contents.proto" (package "runme.contents.v1", syntax proto3)
// tslint:disable
// @ts-nocheck
/* eslint-disable */
// @generated by protobuf-ts 2.11.1 with parameter output_javascript,optimize_code_size,long_type_string,add_pb_suffix,ts_nocheck,eslint_disable
// @generated from protobuf file "runme/contents/v1/contents.proto" (package "runme.contents.v1", syntax proto3)
// tslint:disable
// @ts-nocheck
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * FileType distinguishes files from directories.
 *
 * @generated from protobuf enum runme.contents.v1.FileType
 */
export var FileType;
(function (FileType) {
    /**
     * @generated from protobuf enum value: FILE_TYPE_UNSPECIFIED = 0;
     */
    FileType[FileType["UNSPECIFIED"] = 0] = "UNSPECIFIED";
    /**
     * @generated from protobuf enum value: FILE_TYPE_FILE = 1;
     */
    FileType[FileType["FILE"] = 1] = "FILE";
    /**
     * @generated from protobuf enum value: FILE_TYPE_DIRECTORY = 2;
     */
    FileType[FileType["DIRECTORY"] = 2] = "DIRECTORY";
})(FileType || (FileType = {}));
/**
 * WriteMode controls how Write handles existing files.
 *
 * @generated from protobuf enum runme.contents.v1.WriteMode
 */
export var WriteMode;
(function (WriteMode) {
    /**
     * @generated from protobuf enum value: WRITE_MODE_UNSPECIFIED = 0;
     */
    WriteMode[WriteMode["UNSPECIFIED"] = 0] = "UNSPECIFIED";
    /**
     * @generated from protobuf enum value: WRITE_MODE_OVERWRITE_ALWAYS = 1;
     */
    WriteMode[WriteMode["OVERWRITE_ALWAYS"] = 1] = "OVERWRITE_ALWAYS";
    /**
     * @generated from protobuf enum value: WRITE_MODE_FAIL_IF_EXISTS = 2;
     */
    WriteMode[WriteMode["FAIL_IF_EXISTS"] = 2] = "FAIL_IF_EXISTS";
    /**
     * @generated from protobuf enum value: WRITE_MODE_CREATE_OR_TRUNCATE = 3;
     */
    WriteMode[WriteMode["CREATE_OR_TRUNCATE"] = 3] = "CREATE_OR_TRUNCATE";
})(WriteMode || (WriteMode = {}));
// @generated message type with reflection information, may provide speed optimized methods
class FileInfo$Type extends MessageType {
    constructor() {
        super("runme.contents.v1.FileInfo", [
            { no: 1, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "type", kind: "enum", T: () => ["runme.contents.v1.FileType", FileType, "FILE_TYPE_"] },
            { no: 4, name: "size_bytes", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 5, name: "last_modified_unix_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 6, name: "sha256_hex", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.path = "";
        message.name = "";
        message.type = 0;
        message.sizeBytes = "0";
        message.lastModifiedUnixMs = "0";
        message.sha256Hex = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string path */ 1:
                    message.path = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* runme.contents.v1.FileType type */ 3:
                    message.type = reader.int32();
                    break;
                case /* int64 size_bytes */ 4:
                    message.sizeBytes = reader.int64().toString();
                    break;
                case /* int64 last_modified_unix_ms */ 5:
                    message.lastModifiedUnixMs = reader.int64().toString();
                    break;
                case /* string sha256_hex */ 6:
                    message.sha256Hex = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string path = 1; */
        if (message.path !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.path);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* runme.contents.v1.FileType type = 3; */
        if (message.type !== 0)
            writer.tag(3, WireType.Varint).int32(message.type);
        /* int64 size_bytes = 4; */
        if (message.sizeBytes !== "0")
            writer.tag(4, WireType.Varint).int64(message.sizeBytes);
        /* int64 last_modified_unix_ms = 5; */
        if (message.lastModifiedUnixMs !== "0")
            writer.tag(5, WireType.Varint).int64(message.lastModifiedUnixMs);
        /* string sha256_hex = 6; */
        if (message.sha256Hex !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.sha256Hex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message runme.contents.v1.FileInfo
 */
export const FileInfo = new FileInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListRequest$Type extends MessageType {
    constructor() {
        super("runme.contents.v1.ListRequest", [
            { no: 1, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "include_hashes", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.path = "";
        message.includeHashes = false;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string path */ 1:
                    message.path = reader.string();
                    break;
                case /* bool include_hashes */ 2:
                    message.includeHashes = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string path = 1; */
        if (message.path !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.path);
        /* bool include_hashes = 2; */
        if (message.includeHashes !== false)
            writer.tag(2, WireType.Varint).bool(message.includeHashes);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message runme.contents.v1.ListRequest
 */
export const ListRequest = new ListRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListResponse$Type extends MessageType {
    constructor() {
        super("runme.contents.v1.ListResponse", [
            { no: 1, name: "items", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FileInfo }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.items = [];
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated runme.contents.v1.FileInfo items */ 1:
                    message.items.push(FileInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated runme.contents.v1.FileInfo items = 1; */
        for (let i = 0; i < message.items.length; i++)
            FileInfo.internalBinaryWrite(message.items[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message runme.contents.v1.ListResponse
 */
export const ListResponse = new ListResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadRequest$Type extends MessageType {
    constructor() {
        super("runme.contents.v1.ReadRequest", [
            { no: 1, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "include_hash", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.path = "";
        message.includeHash = false;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string path */ 1:
                    message.path = reader.string();
                    break;
                case /* bool include_hash */ 2:
                    message.includeHash = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string path = 1; */
        if (message.path !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.path);
        /* bool include_hash = 2; */
        if (message.includeHash !== false)
            writer.tag(2, WireType.Varint).bool(message.includeHash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message runme.contents.v1.ReadRequest
 */
export const ReadRequest = new ReadRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadResponse$Type extends MessageType {
    constructor() {
        super("runme.contents.v1.ReadResponse", [
            { no: 1, name: "content", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "info", kind: "message", T: () => FileInfo }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.content = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes content */ 1:
                    message.content = reader.bytes();
                    break;
                case /* runme.contents.v1.FileInfo info */ 2:
                    message.info = FileInfo.internalBinaryRead(reader, reader.uint32(), options, message.info);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bytes content = 1; */
        if (message.content.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.content);
        /* runme.contents.v1.FileInfo info = 2; */
        if (message.info)
            FileInfo.internalBinaryWrite(message.info, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message runme.contents.v1.ReadResponse
 */
export const ReadResponse = new ReadResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatRequest$Type extends MessageType {
    constructor() {
        super("runme.contents.v1.StatRequest", [
            { no: 1, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "include_hash", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.path = "";
        message.includeHash = false;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string path */ 1:
                    message.path = reader.string();
                    break;
                case /* bool include_hash */ 2:
                    message.includeHash = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string path = 1; */
        if (message.path !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.path);
        /* bool include_hash = 2; */
        if (message.includeHash !== false)
            writer.tag(2, WireType.Varint).bool(message.includeHash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message runme.contents.v1.StatRequest
 */
export const StatRequest = new StatRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatResponse$Type extends MessageType {
    constructor() {
        super("runme.contents.v1.StatResponse", [
            { no: 1, name: "info", kind: "message", T: () => FileInfo }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* runme.contents.v1.FileInfo info */ 1:
                    message.info = FileInfo.internalBinaryRead(reader, reader.uint32(), options, message.info);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* runme.contents.v1.FileInfo info = 1; */
        if (message.info)
            FileInfo.internalBinaryWrite(message.info, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message runme.contents.v1.StatResponse
 */
export const StatResponse = new StatResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WriteRequest$Type extends MessageType {
    constructor() {
        super("runme.contents.v1.WriteRequest", [
            { no: 1, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "content", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "expected_version", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "mode", kind: "enum", T: () => ["runme.contents.v1.WriteMode", WriteMode, "WRITE_MODE_"] }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.path = "";
        message.content = new Uint8Array(0);
        message.mode = 0;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string path */ 1:
                    message.path = reader.string();
                    break;
                case /* bytes content */ 2:
                    message.content = reader.bytes();
                    break;
                case /* optional string expected_version */ 3:
                    message.expectedVersion = reader.string();
                    break;
                case /* runme.contents.v1.WriteMode mode */ 4:
                    message.mode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string path = 1; */
        if (message.path !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.path);
        /* bytes content = 2; */
        if (message.content.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.content);
        /* optional string expected_version = 3; */
        if (message.expectedVersion !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.expectedVersion);
        /* runme.contents.v1.WriteMode mode = 4; */
        if (message.mode !== 0)
            writer.tag(4, WireType.Varint).int32(message.mode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message runme.contents.v1.WriteRequest
 */
export const WriteRequest = new WriteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WriteResponse$Type extends MessageType {
    constructor() {
        super("runme.contents.v1.WriteResponse", [
            { no: 1, name: "info", kind: "message", T: () => FileInfo }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* runme.contents.v1.FileInfo info */ 1:
                    message.info = FileInfo.internalBinaryRead(reader, reader.uint32(), options, message.info);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* runme.contents.v1.FileInfo info = 1; */
        if (message.info)
            FileInfo.internalBinaryWrite(message.info, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message runme.contents.v1.WriteResponse
 */
export const WriteResponse = new WriteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RenameRequest$Type extends MessageType {
    constructor() {
        super("runme.contents.v1.RenameRequest", [
            { no: 1, name: "old_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "new_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "expected_version", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.oldPath = "";
        message.newPath = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string old_path */ 1:
                    message.oldPath = reader.string();
                    break;
                case /* string new_path */ 2:
                    message.newPath = reader.string();
                    break;
                case /* optional string expected_version */ 3:
                    message.expectedVersion = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string old_path = 1; */
        if (message.oldPath !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.oldPath);
        /* string new_path = 2; */
        if (message.newPath !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.newPath);
        /* optional string expected_version = 3; */
        if (message.expectedVersion !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.expectedVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message runme.contents.v1.RenameRequest
 */
export const RenameRequest = new RenameRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RenameResponse$Type extends MessageType {
    constructor() {
        super("runme.contents.v1.RenameResponse", [
            { no: 1, name: "info", kind: "message", T: () => FileInfo }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* runme.contents.v1.FileInfo info */ 1:
                    message.info = FileInfo.internalBinaryRead(reader, reader.uint32(), options, message.info);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* runme.contents.v1.FileInfo info = 1; */
        if (message.info)
            FileInfo.internalBinaryWrite(message.info, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message runme.contents.v1.RenameResponse
 */
export const RenameResponse = new RenameResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MkdirRequest$Type extends MessageType {
    constructor() {
        super("runme.contents.v1.MkdirRequest", [
            { no: 1, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.path = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string path */ 1:
                    message.path = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string path = 1; */
        if (message.path !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.path);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message runme.contents.v1.MkdirRequest
 */
export const MkdirRequest = new MkdirRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MkdirResponse$Type extends MessageType {
    constructor() {
        super("runme.contents.v1.MkdirResponse", [
            { no: 1, name: "info", kind: "message", T: () => FileInfo }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* runme.contents.v1.FileInfo info */ 1:
                    message.info = FileInfo.internalBinaryRead(reader, reader.uint32(), options, message.info);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* runme.contents.v1.FileInfo info = 1; */
        if (message.info)
            FileInfo.internalBinaryWrite(message.info, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message runme.contents.v1.MkdirResponse
 */
export const MkdirResponse = new MkdirResponse$Type();
/**
 * @generated ServiceType for protobuf service runme.contents.v1.ContentsService
 */
export const ContentsService = new ServiceType("runme.contents.v1.ContentsService", [
    { name: "List", options: {}, I: ListRequest, O: ListResponse },
    { name: "Read", options: {}, I: ReadRequest, O: ReadResponse },
    { name: "Stat", options: {}, I: StatRequest, O: StatResponse },
    { name: "Write", options: {}, I: WriteRequest, O: WriteResponse },
    { name: "Rename", options: {}, I: RenameRequest, O: RenameResponse },
    { name: "Mkdir", options: {}, I: MkdirRequest, O: MkdirResponse }
]);
