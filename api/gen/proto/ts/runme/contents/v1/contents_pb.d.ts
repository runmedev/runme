/* eslint-disable */
// @generated by protobuf-ts 2.11.1 with parameter output_javascript,optimize_code_size,long_type_string,add_pb_suffix,ts_nocheck,eslint_disable
// @generated from protobuf file "runme/contents/v1/contents.proto" (package "runme.contents.v1", syntax proto3)
// tslint:disable
// @ts-nocheck
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * FileInfo describes a filesystem entry.
 *
 * @generated from protobuf message runme.contents.v1.FileInfo
 */
export interface FileInfo {
    /**
     * Path is the full path to the file or directory.
     *
     * @generated from protobuf field: string path = 1
     */
    path: string;
    /**
     * Name is the base name of the file or directory.
     *
     * @generated from protobuf field: string name = 2
     */
    name: string;
    /**
     * Type indicates whether this entry is a file or directory.
     *
     * @generated from protobuf field: runme.contents.v1.FileType type = 3
     */
    type: FileType;
    /**
     * SizeBytes is the size of the file in bytes.
     *
     * @generated from protobuf field: int64 size_bytes = 4
     */
    sizeBytes: string;
    /**
     * LastModifiedUnixMs is the last modification time in milliseconds since epoch.
     *
     * @generated from protobuf field: int64 last_modified_unix_ms = 5
     */
    lastModifiedUnixMs: string;
    /**
     * Sha256Hex is the hex-encoded SHA-256 hash of the file contents.
     * Empty if hashing was not requested.
     *
     * @generated from protobuf field: string sha256_hex = 6
     */
    sha256Hex: string;
}
/**
 * @generated from protobuf message runme.contents.v1.ListRequest
 */
export interface ListRequest {
    /**
     * Path is the directory to list.
     *
     * @generated from protobuf field: string path = 1
     */
    path: string;
    /**
     * IncludeHashes requests SHA-256 hashes for each returned item.
     *
     * @generated from protobuf field: bool include_hashes = 2
     */
    includeHashes: boolean;
}
/**
 * @generated from protobuf message runme.contents.v1.ListResponse
 */
export interface ListResponse {
    /**
     * @generated from protobuf field: repeated runme.contents.v1.FileInfo items = 1
     */
    items: FileInfo[];
}
/**
 * @generated from protobuf message runme.contents.v1.ReadRequest
 */
export interface ReadRequest {
    /**
     * Path is the file to read.
     *
     * @generated from protobuf field: string path = 1
     */
    path: string;
    /**
     * IncludeHash requests a SHA-256 hash of the file contents.
     *
     * @generated from protobuf field: bool include_hash = 2
     */
    includeHash: boolean;
}
/**
 * @generated from protobuf message runme.contents.v1.ReadResponse
 */
export interface ReadResponse {
    /**
     * Content is the raw file contents.
     *
     * @generated from protobuf field: bytes content = 1
     */
    content: Uint8Array;
    /**
     * Info is metadata about the file that was read.
     *
     * @generated from protobuf field: runme.contents.v1.FileInfo info = 2
     */
    info?: FileInfo;
}
/**
 * @generated from protobuf message runme.contents.v1.StatRequest
 */
export interface StatRequest {
    /**
     * Path is the file or directory to stat.
     *
     * @generated from protobuf field: string path = 1
     */
    path: string;
    /**
     * IncludeHash requests a SHA-256 hash of the file contents.
     *
     * @generated from protobuf field: bool include_hash = 2
     */
    includeHash: boolean;
}
/**
 * @generated from protobuf message runme.contents.v1.StatResponse
 */
export interface StatResponse {
    /**
     * @generated from protobuf field: runme.contents.v1.FileInfo info = 1
     */
    info?: FileInfo;
}
/**
 * @generated from protobuf message runme.contents.v1.WriteRequest
 */
export interface WriteRequest {
    /**
     * Path is the file to write.
     *
     * @generated from protobuf field: string path = 1
     */
    path: string;
    /**
     * Content is the raw bytes to write.
     *
     * @generated from protobuf field: bytes content = 2
     */
    content: Uint8Array;
    /**
     * ExpectedVersion is a SHA-256 hash for conditional writes.
     * When set, the write only succeeds if the current file hash matches.
     *
     * @generated from protobuf field: optional string expected_version = 3
     */
    expectedVersion?: string;
    /**
     * Mode controls behaviour when the target file already exists.
     *
     * @generated from protobuf field: runme.contents.v1.WriteMode mode = 4
     */
    mode: WriteMode;
}
/**
 * @generated from protobuf message runme.contents.v1.WriteResponse
 */
export interface WriteResponse {
    /**
     * Info is metadata about the file after the write.
     *
     * @generated from protobuf field: runme.contents.v1.FileInfo info = 1
     */
    info?: FileInfo;
}
/**
 * @generated from protobuf message runme.contents.v1.RenameRequest
 */
export interface RenameRequest {
    /**
     * OldPath is the current location of the file or directory.
     *
     * @generated from protobuf field: string old_path = 1
     */
    oldPath: string;
    /**
     * NewPath is the desired location.
     *
     * @generated from protobuf field: string new_path = 2
     */
    newPath: string;
    /**
     * ExpectedVersion is a SHA-256 hash for conditional renames.
     * When set, the rename only succeeds if the current file hash matches.
     *
     * @generated from protobuf field: optional string expected_version = 3
     */
    expectedVersion?: string;
}
/**
 * @generated from protobuf message runme.contents.v1.RenameResponse
 */
export interface RenameResponse {
    /**
     * Info is metadata about the entry at its new location.
     *
     * @generated from protobuf field: runme.contents.v1.FileInfo info = 1
     */
    info?: FileInfo;
}
/**
 * @generated from protobuf message runme.contents.v1.MkdirRequest
 */
export interface MkdirRequest {
    /**
     * Path is the directory to create (including parents).
     *
     * @generated from protobuf field: string path = 1
     */
    path: string;
}
/**
 * @generated from protobuf message runme.contents.v1.MkdirResponse
 */
export interface MkdirResponse {
    /**
     * Info is metadata about the created directory.
     *
     * @generated from protobuf field: runme.contents.v1.FileInfo info = 1
     */
    info?: FileInfo;
}
/**
 * FileType distinguishes files from directories.
 *
 * @generated from protobuf enum runme.contents.v1.FileType
 */
export declare enum FileType {
    /**
     * @generated from protobuf enum value: FILE_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: FILE_TYPE_FILE = 1;
     */
    FILE = 1,
    /**
     * @generated from protobuf enum value: FILE_TYPE_DIRECTORY = 2;
     */
    DIRECTORY = 2
}
/**
 * WriteMode controls how Write handles existing files.
 *
 * @generated from protobuf enum runme.contents.v1.WriteMode
 */
export declare enum WriteMode {
    /**
     * @generated from protobuf enum value: WRITE_MODE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: WRITE_MODE_OVERWRITE_ALWAYS = 1;
     */
    OVERWRITE_ALWAYS = 1,
    /**
     * @generated from protobuf enum value: WRITE_MODE_FAIL_IF_EXISTS = 2;
     */
    FAIL_IF_EXISTS = 2,
    /**
     * @generated from protobuf enum value: WRITE_MODE_CREATE_OR_TRUNCATE = 3;
     */
    CREATE_OR_TRUNCATE = 3
}
declare class FileInfo$Type extends MessageType<FileInfo> {
    constructor();
    create(value?: PartialMessage<FileInfo>): FileInfo;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FileInfo): FileInfo;
    internalBinaryWrite(message: FileInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message runme.contents.v1.FileInfo
 */
export declare const FileInfo: FileInfo$Type;
declare class ListRequest$Type extends MessageType<ListRequest> {
    constructor();
    create(value?: PartialMessage<ListRequest>): ListRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListRequest): ListRequest;
    internalBinaryWrite(message: ListRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message runme.contents.v1.ListRequest
 */
export declare const ListRequest: ListRequest$Type;
declare class ListResponse$Type extends MessageType<ListResponse> {
    constructor();
    create(value?: PartialMessage<ListResponse>): ListResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListResponse): ListResponse;
    internalBinaryWrite(message: ListResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message runme.contents.v1.ListResponse
 */
export declare const ListResponse: ListResponse$Type;
declare class ReadRequest$Type extends MessageType<ReadRequest> {
    constructor();
    create(value?: PartialMessage<ReadRequest>): ReadRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadRequest): ReadRequest;
    internalBinaryWrite(message: ReadRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message runme.contents.v1.ReadRequest
 */
export declare const ReadRequest: ReadRequest$Type;
declare class ReadResponse$Type extends MessageType<ReadResponse> {
    constructor();
    create(value?: PartialMessage<ReadResponse>): ReadResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadResponse): ReadResponse;
    internalBinaryWrite(message: ReadResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message runme.contents.v1.ReadResponse
 */
export declare const ReadResponse: ReadResponse$Type;
declare class StatRequest$Type extends MessageType<StatRequest> {
    constructor();
    create(value?: PartialMessage<StatRequest>): StatRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatRequest): StatRequest;
    internalBinaryWrite(message: StatRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message runme.contents.v1.StatRequest
 */
export declare const StatRequest: StatRequest$Type;
declare class StatResponse$Type extends MessageType<StatResponse> {
    constructor();
    create(value?: PartialMessage<StatResponse>): StatResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatResponse): StatResponse;
    internalBinaryWrite(message: StatResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message runme.contents.v1.StatResponse
 */
export declare const StatResponse: StatResponse$Type;
declare class WriteRequest$Type extends MessageType<WriteRequest> {
    constructor();
    create(value?: PartialMessage<WriteRequest>): WriteRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WriteRequest): WriteRequest;
    internalBinaryWrite(message: WriteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message runme.contents.v1.WriteRequest
 */
export declare const WriteRequest: WriteRequest$Type;
declare class WriteResponse$Type extends MessageType<WriteResponse> {
    constructor();
    create(value?: PartialMessage<WriteResponse>): WriteResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WriteResponse): WriteResponse;
    internalBinaryWrite(message: WriteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message runme.contents.v1.WriteResponse
 */
export declare const WriteResponse: WriteResponse$Type;
declare class RenameRequest$Type extends MessageType<RenameRequest> {
    constructor();
    create(value?: PartialMessage<RenameRequest>): RenameRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RenameRequest): RenameRequest;
    internalBinaryWrite(message: RenameRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message runme.contents.v1.RenameRequest
 */
export declare const RenameRequest: RenameRequest$Type;
declare class RenameResponse$Type extends MessageType<RenameResponse> {
    constructor();
    create(value?: PartialMessage<RenameResponse>): RenameResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RenameResponse): RenameResponse;
    internalBinaryWrite(message: RenameResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message runme.contents.v1.RenameResponse
 */
export declare const RenameResponse: RenameResponse$Type;
declare class MkdirRequest$Type extends MessageType<MkdirRequest> {
    constructor();
    create(value?: PartialMessage<MkdirRequest>): MkdirRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MkdirRequest): MkdirRequest;
    internalBinaryWrite(message: MkdirRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message runme.contents.v1.MkdirRequest
 */
export declare const MkdirRequest: MkdirRequest$Type;
declare class MkdirResponse$Type extends MessageType<MkdirResponse> {
    constructor();
    create(value?: PartialMessage<MkdirResponse>): MkdirResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MkdirResponse): MkdirResponse;
    internalBinaryWrite(message: MkdirResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message runme.contents.v1.MkdirResponse
 */
export declare const MkdirResponse: MkdirResponse$Type;
/**
 * @generated ServiceType for protobuf service runme.contents.v1.ContentsService
 */
export declare const ContentsService: any;
export {};
