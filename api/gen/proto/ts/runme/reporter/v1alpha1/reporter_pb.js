/* eslint-disable */
// @generated by protobuf-ts 2.11.1 with parameter output_javascript,optimize_code_size,long_type_string,add_pb_suffix,ts_nocheck,eslint_disable
// @generated from protobuf file "runme/reporter/v1alpha1/reporter.proto" (package "runme.reporter.v1alpha1", syntax proto3)
// tslint:disable
// @ts-nocheck
/* eslint-disable */
// @generated by protobuf-ts 2.11.1 with parameter output_javascript,optimize_code_size,long_type_string,add_pb_suffix,ts_nocheck,eslint_disable
// @generated from protobuf file "runme/reporter/v1alpha1/reporter.proto" (package "runme.reporter.v1alpha1", syntax proto3)
// tslint:disable
// @ts-nocheck
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Notebook } from "../../parser/v1/parser_pb";
// @generated message type with reflection information, may provide speed optimized methods
class TransformRequest$Type extends MessageType {
    constructor() {
        super("runme.reporter.v1alpha1.TransformRequest", [
            { no: 1, name: "notebook", kind: "message", T: () => Notebook },
            { no: 2, name: "extension", kind: "message", T: () => TransformRequestExtension }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* runme.parser.v1.Notebook notebook */ 1:
                    message.notebook = Notebook.internalBinaryRead(reader, reader.uint32(), options, message.notebook);
                    break;
                case /* runme.reporter.v1alpha1.TransformRequestExtension extension */ 2:
                    message.extension = TransformRequestExtension.internalBinaryRead(reader, reader.uint32(), options, message.extension);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* runme.parser.v1.Notebook notebook = 1; */
        if (message.notebook)
            Notebook.internalBinaryWrite(message.notebook, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* runme.reporter.v1alpha1.TransformRequestExtension extension = 2; */
        if (message.extension)
            TransformRequestExtension.internalBinaryWrite(message.extension, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message runme.reporter.v1alpha1.TransformRequest
 */
export const TransformRequest = new TransformRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransformRequestExtension$Type extends MessageType {
    constructor() {
        super("runme.reporter.v1alpha1.TransformRequestExtension", [
            { no: 2, name: "auto_save", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "repository", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "branch", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "commit", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "file_path", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "file_content", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "plain_output", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 9, name: "masked_output", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 10, name: "mac_address", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "hostname", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "platform", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "release", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "arch", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "vendor", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "shell", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "vs_app_host", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "vs_app_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 19, name: "vs_app_session_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "vs_machine_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 21, name: "vs_metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.vsMetadata = {};
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool auto_save */ 2:
                    message.autoSave = reader.bool();
                    break;
                case /* optional string repository */ 3:
                    message.repository = reader.string();
                    break;
                case /* optional string branch */ 4:
                    message.branch = reader.string();
                    break;
                case /* optional string commit */ 5:
                    message.commit = reader.string();
                    break;
                case /* optional string file_path */ 6:
                    message.filePath = reader.string();
                    break;
                case /* optional bytes file_content */ 7:
                    message.fileContent = reader.bytes();
                    break;
                case /* optional bytes plain_output */ 8:
                    message.plainOutput = reader.bytes();
                    break;
                case /* optional bytes masked_output */ 9:
                    message.maskedOutput = reader.bytes();
                    break;
                case /* optional string mac_address */ 10:
                    message.macAddress = reader.string();
                    break;
                case /* optional string hostname */ 11:
                    message.hostname = reader.string();
                    break;
                case /* optional string platform */ 12:
                    message.platform = reader.string();
                    break;
                case /* optional string release */ 13:
                    message.release = reader.string();
                    break;
                case /* optional string arch */ 14:
                    message.arch = reader.string();
                    break;
                case /* optional string vendor */ 15:
                    message.vendor = reader.string();
                    break;
                case /* optional string shell */ 16:
                    message.shell = reader.string();
                    break;
                case /* optional string vs_app_host */ 17:
                    message.vsAppHost = reader.string();
                    break;
                case /* optional string vs_app_name */ 18:
                    message.vsAppName = reader.string();
                    break;
                case /* optional string vs_app_session_id */ 19:
                    message.vsAppSessionId = reader.string();
                    break;
                case /* optional string vs_machine_id */ 20:
                    message.vsMachineId = reader.string();
                    break;
                case /* map<string, string> vs_metadata */ 21:
                    this.binaryReadMap21(message.vsMetadata, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    binaryReadMap21(map, reader, options) {
        let len = reader.uint32(), end = reader.pos + len, key, val;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for runme.reporter.v1alpha1.TransformRequestExtension.vs_metadata");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message, writer, options) {
        /* optional bool auto_save = 2; */
        if (message.autoSave !== undefined)
            writer.tag(2, WireType.Varint).bool(message.autoSave);
        /* optional string repository = 3; */
        if (message.repository !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.repository);
        /* optional string branch = 4; */
        if (message.branch !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.branch);
        /* optional string commit = 5; */
        if (message.commit !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.commit);
        /* optional string file_path = 6; */
        if (message.filePath !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.filePath);
        /* optional bytes file_content = 7; */
        if (message.fileContent !== undefined)
            writer.tag(7, WireType.LengthDelimited).bytes(message.fileContent);
        /* optional bytes plain_output = 8; */
        if (message.plainOutput !== undefined)
            writer.tag(8, WireType.LengthDelimited).bytes(message.plainOutput);
        /* optional bytes masked_output = 9; */
        if (message.maskedOutput !== undefined)
            writer.tag(9, WireType.LengthDelimited).bytes(message.maskedOutput);
        /* optional string mac_address = 10; */
        if (message.macAddress !== undefined)
            writer.tag(10, WireType.LengthDelimited).string(message.macAddress);
        /* optional string hostname = 11; */
        if (message.hostname !== undefined)
            writer.tag(11, WireType.LengthDelimited).string(message.hostname);
        /* optional string platform = 12; */
        if (message.platform !== undefined)
            writer.tag(12, WireType.LengthDelimited).string(message.platform);
        /* optional string release = 13; */
        if (message.release !== undefined)
            writer.tag(13, WireType.LengthDelimited).string(message.release);
        /* optional string arch = 14; */
        if (message.arch !== undefined)
            writer.tag(14, WireType.LengthDelimited).string(message.arch);
        /* optional string vendor = 15; */
        if (message.vendor !== undefined)
            writer.tag(15, WireType.LengthDelimited).string(message.vendor);
        /* optional string shell = 16; */
        if (message.shell !== undefined)
            writer.tag(16, WireType.LengthDelimited).string(message.shell);
        /* optional string vs_app_host = 17; */
        if (message.vsAppHost !== undefined)
            writer.tag(17, WireType.LengthDelimited).string(message.vsAppHost);
        /* optional string vs_app_name = 18; */
        if (message.vsAppName !== undefined)
            writer.tag(18, WireType.LengthDelimited).string(message.vsAppName);
        /* optional string vs_app_session_id = 19; */
        if (message.vsAppSessionId !== undefined)
            writer.tag(19, WireType.LengthDelimited).string(message.vsAppSessionId);
        /* optional string vs_machine_id = 20; */
        if (message.vsMachineId !== undefined)
            writer.tag(20, WireType.LengthDelimited).string(message.vsMachineId);
        /* map<string, string> vs_metadata = 21; */
        for (let k of globalThis.Object.keys(message.vsMetadata))
            writer.tag(21, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.vsMetadata[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message runme.reporter.v1alpha1.TransformRequestExtension
 */
export const TransformRequestExtension = new TransformRequestExtension$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransformResponse$Type extends MessageType {
    constructor() {
        super("runme.reporter.v1alpha1.TransformResponse", [
            { no: 1, name: "notebook", kind: "message", T: () => Notebook },
            { no: 2, name: "extension", kind: "message", T: () => ReporterExtension }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* runme.parser.v1.Notebook notebook */ 1:
                    message.notebook = Notebook.internalBinaryRead(reader, reader.uint32(), options, message.notebook);
                    break;
                case /* runme.reporter.v1alpha1.ReporterExtension extension */ 2:
                    message.extension = ReporterExtension.internalBinaryRead(reader, reader.uint32(), options, message.extension);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* runme.parser.v1.Notebook notebook = 1; */
        if (message.notebook)
            Notebook.internalBinaryWrite(message.notebook, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* runme.reporter.v1alpha1.ReporterExtension extension = 2; */
        if (message.extension)
            ReporterExtension.internalBinaryWrite(message.extension, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message runme.reporter.v1alpha1.TransformResponse
 */
export const TransformResponse = new TransformResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReporterExtension$Type extends MessageType {
    constructor() {
        super("runme.reporter.v1alpha1.ReporterExtension", [
            { no: 1, name: "auto_save", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "git", kind: "message", T: () => ReporterGit },
            { no: 3, name: "file", kind: "message", T: () => ReporterFile },
            { no: 4, name: "session", kind: "message", T: () => ReporterSession },
            { no: 5, name: "device", kind: "message", T: () => ReporterDevice }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.autoSave = false;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool auto_save */ 1:
                    message.autoSave = reader.bool();
                    break;
                case /* runme.reporter.v1alpha1.ReporterGit git */ 2:
                    message.git = ReporterGit.internalBinaryRead(reader, reader.uint32(), options, message.git);
                    break;
                case /* runme.reporter.v1alpha1.ReporterFile file */ 3:
                    message.file = ReporterFile.internalBinaryRead(reader, reader.uint32(), options, message.file);
                    break;
                case /* runme.reporter.v1alpha1.ReporterSession session */ 4:
                    message.session = ReporterSession.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* runme.reporter.v1alpha1.ReporterDevice device */ 5:
                    message.device = ReporterDevice.internalBinaryRead(reader, reader.uint32(), options, message.device);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bool auto_save = 1; */
        if (message.autoSave !== false)
            writer.tag(1, WireType.Varint).bool(message.autoSave);
        /* runme.reporter.v1alpha1.ReporterGit git = 2; */
        if (message.git)
            ReporterGit.internalBinaryWrite(message.git, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* runme.reporter.v1alpha1.ReporterFile file = 3; */
        if (message.file)
            ReporterFile.internalBinaryWrite(message.file, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* runme.reporter.v1alpha1.ReporterSession session = 4; */
        if (message.session)
            ReporterSession.internalBinaryWrite(message.session, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* runme.reporter.v1alpha1.ReporterDevice device = 5; */
        if (message.device)
            ReporterDevice.internalBinaryWrite(message.device, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message runme.reporter.v1alpha1.ReporterExtension
 */
export const ReporterExtension = new ReporterExtension$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReporterGit$Type extends MessageType {
    constructor() {
        super("runme.reporter.v1alpha1.ReporterGit", [
            { no: 1, name: "repository", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "branch", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "commit", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.repository = "";
        message.branch = "";
        message.commit = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string repository */ 1:
                    message.repository = reader.string();
                    break;
                case /* string branch */ 2:
                    message.branch = reader.string();
                    break;
                case /* string commit */ 3:
                    message.commit = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string repository = 1; */
        if (message.repository !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.repository);
        /* string branch = 2; */
        if (message.branch !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.branch);
        /* string commit = 3; */
        if (message.commit !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.commit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message runme.reporter.v1alpha1.ReporterGit
 */
export const ReporterGit = new ReporterGit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReporterSession$Type extends MessageType {
    constructor() {
        super("runme.reporter.v1alpha1.ReporterSession", [
            { no: 1, name: "plain_output", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "masked_output", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.plainOutput = new Uint8Array(0);
        message.maskedOutput = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes plain_output */ 1:
                    message.plainOutput = reader.bytes();
                    break;
                case /* bytes masked_output */ 2:
                    message.maskedOutput = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bytes plain_output = 1; */
        if (message.plainOutput.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.plainOutput);
        /* bytes masked_output = 2; */
        if (message.maskedOutput.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.maskedOutput);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message runme.reporter.v1alpha1.ReporterSession
 */
export const ReporterSession = new ReporterSession$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReporterFile$Type extends MessageType {
    constructor() {
        super("runme.reporter.v1alpha1.ReporterFile", [
            { no: 1, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "content", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.path = "";
        message.content = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string path */ 1:
                    message.path = reader.string();
                    break;
                case /* bytes content */ 2:
                    message.content = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string path = 1; */
        if (message.path !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.path);
        /* bytes content = 2; */
        if (message.content.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.content);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message runme.reporter.v1alpha1.ReporterFile
 */
export const ReporterFile = new ReporterFile$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReporterDevice$Type extends MessageType {
    constructor() {
        super("runme.reporter.v1alpha1.ReporterDevice", [
            { no: 1, name: "mac_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "hostname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "platform", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "release", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "arch", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "vendor", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "shell", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "vs_app_host", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "vs_app_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "vs_app_session_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "vs_machine_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "vs_metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.macAddress = "";
        message.hostname = "";
        message.platform = "";
        message.release = "";
        message.arch = "";
        message.vendor = "";
        message.shell = "";
        message.vsAppHost = "";
        message.vsAppName = "";
        message.vsAppSessionId = "";
        message.vsMachineId = "";
        message.vsMetadata = {};
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string mac_address */ 1:
                    message.macAddress = reader.string();
                    break;
                case /* string hostname */ 2:
                    message.hostname = reader.string();
                    break;
                case /* string platform */ 3:
                    message.platform = reader.string();
                    break;
                case /* string release */ 4:
                    message.release = reader.string();
                    break;
                case /* string arch */ 5:
                    message.arch = reader.string();
                    break;
                case /* string vendor */ 6:
                    message.vendor = reader.string();
                    break;
                case /* string shell */ 7:
                    message.shell = reader.string();
                    break;
                case /* string vs_app_host */ 8:
                    message.vsAppHost = reader.string();
                    break;
                case /* string vs_app_name */ 9:
                    message.vsAppName = reader.string();
                    break;
                case /* string vs_app_session_id */ 10:
                    message.vsAppSessionId = reader.string();
                    break;
                case /* string vs_machine_id */ 11:
                    message.vsMachineId = reader.string();
                    break;
                case /* map<string, string> vs_metadata */ 12:
                    this.binaryReadMap12(message.vsMetadata, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    binaryReadMap12(map, reader, options) {
        let len = reader.uint32(), end = reader.pos + len, key, val;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for runme.reporter.v1alpha1.ReporterDevice.vs_metadata");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message, writer, options) {
        /* string mac_address = 1; */
        if (message.macAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.macAddress);
        /* string hostname = 2; */
        if (message.hostname !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.hostname);
        /* string platform = 3; */
        if (message.platform !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.platform);
        /* string release = 4; */
        if (message.release !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.release);
        /* string arch = 5; */
        if (message.arch !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.arch);
        /* string vendor = 6; */
        if (message.vendor !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.vendor);
        /* string shell = 7; */
        if (message.shell !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.shell);
        /* string vs_app_host = 8; */
        if (message.vsAppHost !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.vsAppHost);
        /* string vs_app_name = 9; */
        if (message.vsAppName !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.vsAppName);
        /* string vs_app_session_id = 10; */
        if (message.vsAppSessionId !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.vsAppSessionId);
        /* string vs_machine_id = 11; */
        if (message.vsMachineId !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.vsMachineId);
        /* map<string, string> vs_metadata = 12; */
        for (let k of globalThis.Object.keys(message.vsMetadata))
            writer.tag(12, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.vsMetadata[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message runme.reporter.v1alpha1.ReporterDevice
 */
export const ReporterDevice = new ReporterDevice$Type();
/**
 * @generated ServiceType for protobuf service runme.reporter.v1alpha1.ReporterService
 */
export const ReporterService = new ServiceType("runme.reporter.v1alpha1.ReporterService", [
    { name: "Transform", options: {}, I: TransformRequest, O: TransformResponse }
]);
