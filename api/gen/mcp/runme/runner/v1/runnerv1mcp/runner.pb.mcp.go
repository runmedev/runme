// Code generated by protoc-gen-mcp-go. DO NOT EDIT.
// source: runme/runner/v1/runner.proto

package runnerv1mcp

import (
	v1 "github.com/runmedev/runme/v3/api/gen/proto/go/runme/runner/v1"
)

import (
	"context"
	"github.com/mark3labs/mcp-go/mcp"
	mcpserver "github.com/mark3labs/mcp-go/server"
	"encoding/json"
	"google.golang.org/protobuf/encoding/protojson"
	"connectrpc.com/connect"
	grpc "google.golang.org/grpc"
	"github.com/redpanda-data/protoc-gen-go-mcp/pkg/runtime"
)

var (
	RunnerService_CreateSessionTool        = mcp.Tool{Meta: (*mcp.Meta)(nil), Name: "runme_runner_v1_RunnerService_CreateSession", Description: "", InputSchema: mcp.ToolInputSchema{Defs: map[string]interface{}(nil), Type: "", Properties: map[string]interface{}(nil), Required: []string(nil)}, RawInputSchema: json.RawMessage{0x7b, 0x22, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x65, 0x6e, 0x76, 0x5f, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x7b, 0x22, 0x65, 0x6e, 0x75, 0x6d, 0x22, 0x3a, 0x5b, 0x22, 0x53, 0x45, 0x53, 0x53, 0x49, 0x4f, 0x4e, 0x5f, 0x45, 0x4e, 0x56, 0x5f, 0x53, 0x54, 0x4f, 0x52, 0x45, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x22, 0x2c, 0x22, 0x53, 0x45, 0x53, 0x53, 0x49, 0x4f, 0x4e, 0x5f, 0x45, 0x4e, 0x56, 0x5f, 0x53, 0x54, 0x4f, 0x52, 0x45, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x4f, 0x57, 0x4c, 0x22, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x2c, 0x22, 0x65, 0x6e, 0x76, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x61, 0x72, 0x72, 0x61, 0x79, 0x22, 0x7d, 0x2c, 0x22, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x22, 0x3a, 0x7b, 0x22, 0x61, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x2c, 0x22, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x79, 0x4e, 0x61, 0x6d, 0x65, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x22, 0x7d, 0x2c, 0x22, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x22, 0x3a, 0x7b, 0x22, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x65, 0x6e, 0x76, 0x5f, 0x64, 0x69, 0x72, 0x65, 0x6e, 0x76, 0x22, 0x3a, 0x7b, 0x22, 0x65, 0x6e, 0x75, 0x6d, 0x22, 0x3a, 0x5b, 0x22, 0x44, 0x49, 0x52, 0x5f, 0x45, 0x4e, 0x56, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x22, 0x2c, 0x22, 0x44, 0x49, 0x52, 0x5f, 0x45, 0x4e, 0x56, 0x5f, 0x45, 0x4e, 0x41, 0x42, 0x4c, 0x45, 0x44, 0x5f, 0x57, 0x41, 0x52, 0x4e, 0x22, 0x2c, 0x22, 0x44, 0x49, 0x52, 0x5f, 0x45, 0x4e, 0x56, 0x5f, 0x45, 0x4e, 0x41, 0x42, 0x4c, 0x45, 0x44, 0x5f, 0x45, 0x52, 0x52, 0x4f, 0x52, 0x22, 0x2c, 0x22, 0x44, 0x49, 0x52, 0x5f, 0x45, 0x4e, 0x56, 0x5f, 0x44, 0x49, 0x53, 0x41, 0x42, 0x4c, 0x45, 0x44, 0x22, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x2c, 0x22, 0x65, 0x6e, 0x76, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x22, 0x3a, 0x7b, 0x22, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x61, 0x72, 0x72, 0x61, 0x79, 0x22, 0x7d, 0x2c, 0x22, 0x72, 0x6f, 0x6f, 0x74, 0x22, 0x3a, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x7d, 0x2c, 0x22, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x22, 0x3a, 0x5b, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x22, 0x7d, 0x7d, 0x2c, 0x22, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x22, 0x3a, 0x5b, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x22, 0x7d}, RawOutputSchema: json.RawMessage(nil), Annotations: mcp.ToolAnnotation{Title: "", ReadOnlyHint: (*bool)(nil), DestructiveHint: (*bool)(nil), IdempotentHint: (*bool)(nil), OpenWorldHint: (*bool)(nil)}}
	RunnerService_DeleteSessionTool        = mcp.Tool{Meta: (*mcp.Meta)(nil), Name: "runme_runner_v1_RunnerService_DeleteSession", Description: "", InputSchema: mcp.ToolInputSchema{Defs: map[string]interface{}(nil), Type: "", Properties: map[string]interface{}(nil), Required: []string(nil)}, RawInputSchema: json.RawMessage{0x7b, 0x22, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x69, 0x64, 0x22, 0x3a, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x7d, 0x2c, 0x22, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x22, 0x3a, 0x5b, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x22, 0x7d}, RawOutputSchema: json.RawMessage(nil), Annotations: mcp.ToolAnnotation{Title: "", ReadOnlyHint: (*bool)(nil), DestructiveHint: (*bool)(nil), IdempotentHint: (*bool)(nil), OpenWorldHint: (*bool)(nil)}}
	RunnerService_GetSessionTool           = mcp.Tool{Meta: (*mcp.Meta)(nil), Name: "runme_runner_v1_RunnerService_GetSession", Description: "", InputSchema: mcp.ToolInputSchema{Defs: map[string]interface{}(nil), Type: "", Properties: map[string]interface{}(nil), Required: []string(nil)}, RawInputSchema: json.RawMessage{0x7b, 0x22, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x69, 0x64, 0x22, 0x3a, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x7d, 0x2c, 0x22, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x22, 0x3a, 0x5b, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x22, 0x7d}, RawOutputSchema: json.RawMessage(nil), Annotations: mcp.ToolAnnotation{Title: "", ReadOnlyHint: (*bool)(nil), DestructiveHint: (*bool)(nil), IdempotentHint: (*bool)(nil), OpenWorldHint: (*bool)(nil)}}
	RunnerService_ListSessionsTool         = mcp.Tool{Meta: (*mcp.Meta)(nil), Name: "runme_runner_v1_RunnerService_ListSessions", Description: "", InputSchema: mcp.ToolInputSchema{Defs: map[string]interface{}(nil), Type: "", Properties: map[string]interface{}(nil), Required: []string(nil)}, RawInputSchema: json.RawMessage{0x7b, 0x22, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x3a, 0x7b, 0x7d, 0x2c, 0x22, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x22, 0x3a, 0x5b, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x22, 0x7d}, RawOutputSchema: json.RawMessage(nil), Annotations: mcp.ToolAnnotation{Title: "", ReadOnlyHint: (*bool)(nil), DestructiveHint: (*bool)(nil), IdempotentHint: (*bool)(nil), OpenWorldHint: (*bool)(nil)}}
	RunnerService_ResolveProgramTool       = mcp.Tool{Meta: (*mcp.Meta)(nil), Name: "runme_runner_v1_RunnerService_ResolveProgram", Description: "ResolveProgram resolves variables from a script or a list of commands\nusing the provided sources, which can be a list of environment variables,\na session, or a project.\nFor now, the resolved variables are only the exported ones using `export`.\n", InputSchema: mcp.ToolInputSchema{Defs: map[string]interface{}(nil), Type: "", Properties: map[string]interface{}(nil), Required: []string(nil)}, RawInputSchema: json.RawMessage{0x7b, 0x22, 0x61, 0x6e, 0x79, 0x4f, 0x66, 0x22, 0x3a, 0x5b, 0x7b, 0x22, 0x24, 0x63, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x22, 0x3a, 0x22, 0x49, 0x6e, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2c, 0x20, 0x74, 0x68, 0x65, 0x72, 0x65, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x6f, 0x6e, 0x65, 0x4f, 0x66, 0x20, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x65, 0x76, 0x65, 0x72, 0x79, 0x20, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x20, 0x6f, 0x6e, 0x65, 0x4f, 0x66, 0x20, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x2e, 0x22, 0x2c, 0x22, 0x6f, 0x6e, 0x65, 0x4f, 0x66, 0x22, 0x3a, 0x5b, 0x7b, 0x22, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x6c, 0x69, 0x6e, 0x65, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x61, 0x72, 0x72, 0x61, 0x79, 0x22, 0x7d, 0x7d, 0x2c, 0x22, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x22, 0x3a, 0x5b, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x22, 0x7d, 0x7d, 0x2c, 0x22, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x22, 0x3a, 0x5b, 0x22, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x73, 0x22, 0x5d, 0x7d, 0x2c, 0x7b, 0x22, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x22, 0x3a, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x7d, 0x2c, 0x22, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x22, 0x3a, 0x5b, 0x22, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x22, 0x5d, 0x7d, 0x5d, 0x7d, 0x5d, 0x2c, 0x22, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x65, 0x6e, 0x76, 0x22, 0x3a, 0x7b, 0x22, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x61, 0x72, 0x72, 0x61, 0x79, 0x22, 0x7d, 0x2c, 0x22, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x5f, 0x69, 0x64, 0x22, 0x3a, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x2c, 0x22, 0x6d, 0x6f, 0x64, 0x65, 0x22, 0x3a, 0x7b, 0x22, 0x65, 0x6e, 0x75, 0x6d, 0x22, 0x3a, 0x5b, 0x22, 0x4d, 0x4f, 0x44, 0x45, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x22, 0x2c, 0x22, 0x4d, 0x4f, 0x44, 0x45, 0x5f, 0x50, 0x52, 0x4f, 0x4d, 0x50, 0x54, 0x5f, 0x41, 0x4c, 0x4c, 0x22, 0x2c, 0x22, 0x4d, 0x4f, 0x44, 0x45, 0x5f, 0x53, 0x4b, 0x49, 0x50, 0x5f, 0x41, 0x4c, 0x4c, 0x22, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x2c, 0x22, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x22, 0x3a, 0x7b, 0x22, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x65, 0x6e, 0x76, 0x5f, 0x64, 0x69, 0x72, 0x65, 0x6e, 0x76, 0x22, 0x3a, 0x7b, 0x22, 0x65, 0x6e, 0x75, 0x6d, 0x22, 0x3a, 0x5b, 0x22, 0x44, 0x49, 0x52, 0x5f, 0x45, 0x4e, 0x56, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x22, 0x2c, 0x22, 0x44, 0x49, 0x52, 0x5f, 0x45, 0x4e, 0x56, 0x5f, 0x45, 0x4e, 0x41, 0x42, 0x4c, 0x45, 0x44, 0x5f, 0x57, 0x41, 0x52, 0x4e, 0x22, 0x2c, 0x22, 0x44, 0x49, 0x52, 0x5f, 0x45, 0x4e, 0x56, 0x5f, 0x45, 0x4e, 0x41, 0x42, 0x4c, 0x45, 0x44, 0x5f, 0x45, 0x52, 0x52, 0x4f, 0x52, 0x22, 0x2c, 0x22, 0x44, 0x49, 0x52, 0x5f, 0x45, 0x4e, 0x56, 0x5f, 0x44, 0x49, 0x53, 0x41, 0x42, 0x4c, 0x45, 0x44, 0x22, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x2c, 0x22, 0x65, 0x6e, 0x76, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x22, 0x3a, 0x7b, 0x22, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x61, 0x72, 0x72, 0x61, 0x79, 0x22, 0x7d, 0x2c, 0x22, 0x72, 0x6f, 0x6f, 0x74, 0x22, 0x3a, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x7d, 0x2c, 0x22, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x22, 0x3a, 0x5b, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x22, 0x7d, 0x2c, 0x22, 0x72, 0x65, 0x74, 0x65, 0x6e, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x3a, 0x7b, 0x22, 0x65, 0x6e, 0x75, 0x6d, 0x22, 0x3a, 0x5b, 0x22, 0x52, 0x45, 0x54, 0x45, 0x4e, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x22, 0x2c, 0x22, 0x52, 0x45, 0x54, 0x45, 0x4e, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x46, 0x49, 0x52, 0x53, 0x54, 0x5f, 0x52, 0x55, 0x4e, 0x22, 0x2c, 0x22, 0x52, 0x45, 0x54, 0x45, 0x4e, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x4c, 0x41, 0x53, 0x54, 0x5f, 0x52, 0x55, 0x4e, 0x22, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x2c, 0x22, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x22, 0x3a, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x2c, 0x22, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x73, 0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x22, 0x3a, 0x7b, 0x22, 0x65, 0x6e, 0x75, 0x6d, 0x22, 0x3a, 0x5b, 0x22, 0x53, 0x45, 0x53, 0x53, 0x49, 0x4f, 0x4e, 0x5f, 0x53, 0x54, 0x52, 0x41, 0x54, 0x45, 0x47, 0x59, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x22, 0x2c, 0x22, 0x53, 0x45, 0x53, 0x53, 0x49, 0x4f, 0x4e, 0x5f, 0x53, 0x54, 0x52, 0x41, 0x54, 0x45, 0x47, 0x59, 0x5f, 0x4d, 0x4f, 0x53, 0x54, 0x5f, 0x52, 0x45, 0x43, 0x45, 0x4e, 0x54, 0x22, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x7d, 0x2c, 0x22, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x22, 0x3a, 0x5b, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x22, 0x7d}, RawOutputSchema: json.RawMessage(nil), Annotations: mcp.ToolAnnotation{Title: "", ReadOnlyHint: (*bool)(nil), DestructiveHint: (*bool)(nil), IdempotentHint: (*bool)(nil), OpenWorldHint: (*bool)(nil)}}
	RunnerService_CreateSessionToolOpenAI  = mcp.Tool{Meta: (*mcp.Meta)(nil), Name: "runme_runner_v1_RunnerService_CreateSession", Description: "", InputSchema: mcp.ToolInputSchema{Defs: map[string]interface{}(nil), Type: "", Properties: map[string]interface{}(nil), Required: []string(nil)}, RawInputSchema: json.RawMessage{0x7b, 0x22, 0x61, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x3a, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x2c, 0x22, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x65, 0x6e, 0x76, 0x5f, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x7b, 0x22, 0x65, 0x6e, 0x75, 0x6d, 0x22, 0x3a, 0x5b, 0x22, 0x53, 0x45, 0x53, 0x53, 0x49, 0x4f, 0x4e, 0x5f, 0x45, 0x4e, 0x56, 0x5f, 0x53, 0x54, 0x4f, 0x52, 0x45, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x22, 0x2c, 0x22, 0x53, 0x45, 0x53, 0x53, 0x49, 0x4f, 0x4e, 0x5f, 0x45, 0x4e, 0x56, 0x5f, 0x53, 0x54, 0x4f, 0x52, 0x45, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x4f, 0x57, 0x4c, 0x22, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x2c, 0x22, 0x65, 0x6e, 0x76, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x61, 0x72, 0x72, 0x61, 0x79, 0x22, 0x7d, 0x2c, 0x22, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x22, 0x3a, 0x7b, 0x22, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x3a, 0x22, 0x4c, 0x69, 0x73, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x6b, 0x65, 0x79, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x20, 0x70, 0x61, 0x69, 0x72, 0x73, 0x22, 0x2c, 0x22, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x61, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x3a, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x2c, 0x22, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x6b, 0x65, 0x79, 0x22, 0x3a, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x2c, 0x22, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x22, 0x3a, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x7d, 0x2c, 0x22, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x22, 0x3a, 0x5b, 0x22, 0x6b, 0x65, 0x79, 0x22, 0x2c, 0x22, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x22, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x22, 0x7d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x61, 0x72, 0x72, 0x61, 0x79, 0x22, 0x7d, 0x2c, 0x22, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x22, 0x3a, 0x7b, 0x22, 0x61, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x3a, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x2c, 0x22, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x65, 0x6e, 0x76, 0x5f, 0x64, 0x69, 0x72, 0x65, 0x6e, 0x76, 0x22, 0x3a, 0x7b, 0x22, 0x65, 0x6e, 0x75, 0x6d, 0x22, 0x3a, 0x5b, 0x22, 0x44, 0x49, 0x52, 0x5f, 0x45, 0x4e, 0x56, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x22, 0x2c, 0x22, 0x44, 0x49, 0x52, 0x5f, 0x45, 0x4e, 0x56, 0x5f, 0x45, 0x4e, 0x41, 0x42, 0x4c, 0x45, 0x44, 0x5f, 0x57, 0x41, 0x52, 0x4e, 0x22, 0x2c, 0x22, 0x44, 0x49, 0x52, 0x5f, 0x45, 0x4e, 0x56, 0x5f, 0x45, 0x4e, 0x41, 0x42, 0x4c, 0x45, 0x44, 0x5f, 0x45, 0x52, 0x52, 0x4f, 0x52, 0x22, 0x2c, 0x22, 0x44, 0x49, 0x52, 0x5f, 0x45, 0x4e, 0x56, 0x5f, 0x44, 0x49, 0x53, 0x41, 0x42, 0x4c, 0x45, 0x44, 0x22, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x2c, 0x22, 0x65, 0x6e, 0x76, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x22, 0x3a, 0x7b, 0x22, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x61, 0x72, 0x72, 0x61, 0x79, 0x22, 0x7d, 0x2c, 0x22, 0x72, 0x6f, 0x6f, 0x74, 0x22, 0x3a, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x7d, 0x2c, 0x22, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x22, 0x3a, 0x5b, 0x22, 0x72, 0x6f, 0x6f, 0x74, 0x22, 0x2c, 0x22, 0x65, 0x6e, 0x76, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x22, 0x2c, 0x22, 0x65, 0x6e, 0x76, 0x5f, 0x64, 0x69, 0x72, 0x65, 0x6e, 0x76, 0x22, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x5b, 0x22, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x22, 0x2c, 0x22, 0x6e, 0x75, 0x6c, 0x6c, 0x22, 0x5d, 0x7d, 0x7d, 0x2c, 0x22, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x22, 0x3a, 0x5b, 0x22, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x22, 0x2c, 0x22, 0x65, 0x6e, 0x76, 0x73, 0x22, 0x2c, 0x22, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x22, 0x2c, 0x22, 0x65, 0x6e, 0x76, 0x5f, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x22, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x22, 0x7d}, RawOutputSchema: json.RawMessage(nil), Annotations: mcp.ToolAnnotation{Title: "", ReadOnlyHint: (*bool)(nil), DestructiveHint: (*bool)(nil), IdempotentHint: (*bool)(nil), OpenWorldHint: (*bool)(nil)}}
	RunnerService_DeleteSessionToolOpenAI  = mcp.Tool{Meta: (*mcp.Meta)(nil), Name: "runme_runner_v1_RunnerService_DeleteSession", Description: "", InputSchema: mcp.ToolInputSchema{Defs: map[string]interface{}(nil), Type: "", Properties: map[string]interface{}(nil), Required: []string(nil)}, RawInputSchema: json.RawMessage{0x7b, 0x22, 0x61, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x3a, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x2c, 0x22, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x69, 0x64, 0x22, 0x3a, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x7d, 0x2c, 0x22, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x22, 0x3a, 0x5b, 0x22, 0x69, 0x64, 0x22, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x22, 0x7d}, RawOutputSchema: json.RawMessage(nil), Annotations: mcp.ToolAnnotation{Title: "", ReadOnlyHint: (*bool)(nil), DestructiveHint: (*bool)(nil), IdempotentHint: (*bool)(nil), OpenWorldHint: (*bool)(nil)}}
	RunnerService_GetSessionToolOpenAI     = mcp.Tool{Meta: (*mcp.Meta)(nil), Name: "runme_runner_v1_RunnerService_GetSession", Description: "", InputSchema: mcp.ToolInputSchema{Defs: map[string]interface{}(nil), Type: "", Properties: map[string]interface{}(nil), Required: []string(nil)}, RawInputSchema: json.RawMessage{0x7b, 0x22, 0x61, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x3a, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x2c, 0x22, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x69, 0x64, 0x22, 0x3a, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x7d, 0x2c, 0x22, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x22, 0x3a, 0x5b, 0x22, 0x69, 0x64, 0x22, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x22, 0x7d}, RawOutputSchema: json.RawMessage(nil), Annotations: mcp.ToolAnnotation{Title: "", ReadOnlyHint: (*bool)(nil), DestructiveHint: (*bool)(nil), IdempotentHint: (*bool)(nil), OpenWorldHint: (*bool)(nil)}}
	RunnerService_ListSessionsToolOpenAI   = mcp.Tool{Meta: (*mcp.Meta)(nil), Name: "runme_runner_v1_RunnerService_ListSessions", Description: "", InputSchema: mcp.ToolInputSchema{Defs: map[string]interface{}(nil), Type: "", Properties: map[string]interface{}(nil), Required: []string(nil)}, RawInputSchema: json.RawMessage{0x7b, 0x22, 0x61, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x3a, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x2c, 0x22, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x3a, 0x7b, 0x7d, 0x2c, 0x22, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x22, 0x3a, 0x5b, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x22, 0x7d}, RawOutputSchema: json.RawMessage(nil), Annotations: mcp.ToolAnnotation{Title: "", ReadOnlyHint: (*bool)(nil), DestructiveHint: (*bool)(nil), IdempotentHint: (*bool)(nil), OpenWorldHint: (*bool)(nil)}}
	RunnerService_ResolveProgramToolOpenAI = mcp.Tool{Meta: (*mcp.Meta)(nil), Name: "runme_runner_v1_RunnerService_ResolveProgram", Description: "ResolveProgram resolves variables from a script or a list of commands\nusing the provided sources, which can be a list of environment variables,\na session, or a project.\nFor now, the resolved variables are only the exported ones using `export`.\n", InputSchema: mcp.ToolInputSchema{Defs: map[string]interface{}(nil), Type: "", Properties: map[string]interface{}(nil), Required: []string(nil)}, RawInputSchema: json.RawMessage{0x7b, 0x22, 0x61, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x3a, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x2c, 0x22, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x61, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x3a, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x2c, 0x22, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x3a, 0x22, 0x4e, 0x6f, 0x74, 0x65, 0x3a, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x20, 0x69, 0x73, 0x20, 0x70, 0x61, 0x72, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x27, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x27, 0x20, 0x6f, 0x6e, 0x65, 0x6f, 0x66, 0x20, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x2e, 0x20, 0x4f, 0x6e, 0x6c, 0x79, 0x20, 0x6f, 0x6e, 0x65, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x62, 0x65, 0x20, 0x73, 0x65, 0x74, 0x20, 0x61, 0x74, 0x20, 0x61, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x2e, 0x20, 0x53, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x65, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x73, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x20, 0x57, 0x49, 0x4c, 0x4c, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x20, 0x69, 0x6e, 0x20, 0x61, 0x6e, 0x20, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x2e, 0x20, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x20, 0x6f, 0x6e, 0x65, 0x4f, 0x66, 0x20, 0x73, 0x65, 0x6d, 0x61, 0x6e, 0x74, 0x69, 0x63, 0x73, 0x20, 0x61, 0x70, 0x70, 0x6c, 0x79, 0x2e, 0x22, 0x2c, 0x22, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x6c, 0x69, 0x6e, 0x65, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x61, 0x72, 0x72, 0x61, 0x79, 0x22, 0x7d, 0x7d, 0x2c, 0x22, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x22, 0x3a, 0x5b, 0x22, 0x6c, 0x69, 0x6e, 0x65, 0x73, 0x22, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x5b, 0x22, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x22, 0x2c, 0x22, 0x6e, 0x75, 0x6c, 0x6c, 0x22, 0x5d, 0x7d, 0x2c, 0x22, 0x65, 0x6e, 0x76, 0x22, 0x3a, 0x7b, 0x22, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x61, 0x72, 0x72, 0x61, 0x79, 0x22, 0x7d, 0x2c, 0x22, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x5f, 0x69, 0x64, 0x22, 0x3a, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x2c, 0x22, 0x6d, 0x6f, 0x64, 0x65, 0x22, 0x3a, 0x7b, 0x22, 0x65, 0x6e, 0x75, 0x6d, 0x22, 0x3a, 0x5b, 0x22, 0x4d, 0x4f, 0x44, 0x45, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x22, 0x2c, 0x22, 0x4d, 0x4f, 0x44, 0x45, 0x5f, 0x50, 0x52, 0x4f, 0x4d, 0x50, 0x54, 0x5f, 0x41, 0x4c, 0x4c, 0x22, 0x2c, 0x22, 0x4d, 0x4f, 0x44, 0x45, 0x5f, 0x53, 0x4b, 0x49, 0x50, 0x5f, 0x41, 0x4c, 0x4c, 0x22, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x2c, 0x22, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x22, 0x3a, 0x7b, 0x22, 0x61, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x3a, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x2c, 0x22, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x65, 0x6e, 0x76, 0x5f, 0x64, 0x69, 0x72, 0x65, 0x6e, 0x76, 0x22, 0x3a, 0x7b, 0x22, 0x65, 0x6e, 0x75, 0x6d, 0x22, 0x3a, 0x5b, 0x22, 0x44, 0x49, 0x52, 0x5f, 0x45, 0x4e, 0x56, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x22, 0x2c, 0x22, 0x44, 0x49, 0x52, 0x5f, 0x45, 0x4e, 0x56, 0x5f, 0x45, 0x4e, 0x41, 0x42, 0x4c, 0x45, 0x44, 0x5f, 0x57, 0x41, 0x52, 0x4e, 0x22, 0x2c, 0x22, 0x44, 0x49, 0x52, 0x5f, 0x45, 0x4e, 0x56, 0x5f, 0x45, 0x4e, 0x41, 0x42, 0x4c, 0x45, 0x44, 0x5f, 0x45, 0x52, 0x52, 0x4f, 0x52, 0x22, 0x2c, 0x22, 0x44, 0x49, 0x52, 0x5f, 0x45, 0x4e, 0x56, 0x5f, 0x44, 0x49, 0x53, 0x41, 0x42, 0x4c, 0x45, 0x44, 0x22, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x2c, 0x22, 0x65, 0x6e, 0x76, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x22, 0x3a, 0x7b, 0x22, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x61, 0x72, 0x72, 0x61, 0x79, 0x22, 0x7d, 0x2c, 0x22, 0x72, 0x6f, 0x6f, 0x74, 0x22, 0x3a, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x7d, 0x2c, 0x22, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x22, 0x3a, 0x5b, 0x22, 0x72, 0x6f, 0x6f, 0x74, 0x22, 0x2c, 0x22, 0x65, 0x6e, 0x76, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x22, 0x2c, 0x22, 0x65, 0x6e, 0x76, 0x5f, 0x64, 0x69, 0x72, 0x65, 0x6e, 0x76, 0x22, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x5b, 0x22, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x22, 0x2c, 0x22, 0x6e, 0x75, 0x6c, 0x6c, 0x22, 0x5d, 0x7d, 0x2c, 0x22, 0x72, 0x65, 0x74, 0x65, 0x6e, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x3a, 0x7b, 0x22, 0x65, 0x6e, 0x75, 0x6d, 0x22, 0x3a, 0x5b, 0x22, 0x52, 0x45, 0x54, 0x45, 0x4e, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x22, 0x2c, 0x22, 0x52, 0x45, 0x54, 0x45, 0x4e, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x46, 0x49, 0x52, 0x53, 0x54, 0x5f, 0x52, 0x55, 0x4e, 0x22, 0x2c, 0x22, 0x52, 0x45, 0x54, 0x45, 0x4e, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x4c, 0x41, 0x53, 0x54, 0x5f, 0x52, 0x55, 0x4e, 0x22, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x2c, 0x22, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x22, 0x3a, 0x7b, 0x22, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x3a, 0x22, 0x4e, 0x6f, 0x74, 0x65, 0x3a, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x20, 0x69, 0x73, 0x20, 0x70, 0x61, 0x72, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x27, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x27, 0x20, 0x6f, 0x6e, 0x65, 0x6f, 0x66, 0x20, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x2e, 0x20, 0x4f, 0x6e, 0x6c, 0x79, 0x20, 0x6f, 0x6e, 0x65, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x62, 0x65, 0x20, 0x73, 0x65, 0x74, 0x20, 0x61, 0x74, 0x20, 0x61, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x2e, 0x20, 0x53, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x65, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x73, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x20, 0x57, 0x49, 0x4c, 0x4c, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x20, 0x69, 0x6e, 0x20, 0x61, 0x6e, 0x20, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x2e, 0x20, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x20, 0x6f, 0x6e, 0x65, 0x4f, 0x66, 0x20, 0x73, 0x65, 0x6d, 0x61, 0x6e, 0x74, 0x69, 0x63, 0x73, 0x20, 0x61, 0x70, 0x70, 0x6c, 0x79, 0x2e, 0x22, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x5b, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x2c, 0x22, 0x6e, 0x75, 0x6c, 0x6c, 0x22, 0x5d, 0x7d, 0x2c, 0x22, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x22, 0x3a, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x2c, 0x22, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x73, 0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x22, 0x3a, 0x7b, 0x22, 0x65, 0x6e, 0x75, 0x6d, 0x22, 0x3a, 0x5b, 0x22, 0x53, 0x45, 0x53, 0x53, 0x49, 0x4f, 0x4e, 0x5f, 0x53, 0x54, 0x52, 0x41, 0x54, 0x45, 0x47, 0x59, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x22, 0x2c, 0x22, 0x53, 0x45, 0x53, 0x53, 0x49, 0x4f, 0x4e, 0x5f, 0x53, 0x54, 0x52, 0x41, 0x54, 0x45, 0x47, 0x59, 0x5f, 0x4d, 0x4f, 0x53, 0x54, 0x5f, 0x52, 0x45, 0x43, 0x45, 0x4e, 0x54, 0x22, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x7d, 0x2c, 0x22, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x22, 0x3a, 0x5b, 0x22, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x73, 0x22, 0x2c, 0x22, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x22, 0x2c, 0x22, 0x6d, 0x6f, 0x64, 0x65, 0x22, 0x2c, 0x22, 0x65, 0x6e, 0x76, 0x22, 0x2c, 0x22, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x22, 0x2c, 0x22, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x73, 0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x22, 0x2c, 0x22, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x22, 0x2c, 0x22, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x5f, 0x69, 0x64, 0x22, 0x2c, 0x22, 0x72, 0x65, 0x74, 0x65, 0x6e, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x22, 0x7d}, RawOutputSchema: json.RawMessage(nil), Annotations: mcp.ToolAnnotation{Title: "", ReadOnlyHint: (*bool)(nil), DestructiveHint: (*bool)(nil), IdempotentHint: (*bool)(nil), OpenWorldHint: (*bool)(nil)}}
)

// RunnerServiceServer is compatible with the grpc-go server interface.
type RunnerServiceServer interface {
	CreateSession(ctx context.Context, req *v1.CreateSessionRequest) (*v1.CreateSessionResponse, error)
	DeleteSession(ctx context.Context, req *v1.DeleteSessionRequest) (*v1.DeleteSessionResponse, error)
	GetSession(ctx context.Context, req *v1.GetSessionRequest) (*v1.GetSessionResponse, error)
	ListSessions(ctx context.Context, req *v1.ListSessionsRequest) (*v1.ListSessionsResponse, error)
	ResolveProgram(ctx context.Context, req *v1.ResolveProgramRequest) (*v1.ResolveProgramResponse, error)
}

// RegisterRunnerServiceHandler registers standard MCP handlers for RunnerService
func RegisterRunnerServiceHandler(s *mcpserver.MCPServer, srv RunnerServiceServer, opts ...runtime.Option) {
	config := runtime.NewConfig()
	for _, opt := range opts {
		opt(config)
	}
	CreateSessionTool := RunnerService_CreateSessionTool
	// Add extra properties to schema if configured
	if len(config.ExtraProperties) > 0 {
		CreateSessionTool = runtime.AddExtraPropertiesToTool(CreateSessionTool, config.ExtraProperties)
	}

	s.AddTool(CreateSessionTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req v1.CreateSessionRequest

		message := request.GetArguments()

		// Extract extra properties if configured
		for _, prop := range config.ExtraProperties {
			if propVal, ok := message[prop.Name]; ok {
				ctx = context.WithValue(ctx, prop.ContextKey, propVal)
			}
		}

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := srv.CreateSession(ctx, &req)
		if err != nil {
			return runtime.HandleError(err)
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}

		return mcp.NewToolResultText(string(marshaled)), nil
	})
	DeleteSessionTool := RunnerService_DeleteSessionTool
	// Add extra properties to schema if configured
	if len(config.ExtraProperties) > 0 {
		DeleteSessionTool = runtime.AddExtraPropertiesToTool(DeleteSessionTool, config.ExtraProperties)
	}

	s.AddTool(DeleteSessionTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req v1.DeleteSessionRequest

		message := request.GetArguments()

		// Extract extra properties if configured
		for _, prop := range config.ExtraProperties {
			if propVal, ok := message[prop.Name]; ok {
				ctx = context.WithValue(ctx, prop.ContextKey, propVal)
			}
		}

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := srv.DeleteSession(ctx, &req)
		if err != nil {
			return runtime.HandleError(err)
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}

		return mcp.NewToolResultText(string(marshaled)), nil
	})
	GetSessionTool := RunnerService_GetSessionTool
	// Add extra properties to schema if configured
	if len(config.ExtraProperties) > 0 {
		GetSessionTool = runtime.AddExtraPropertiesToTool(GetSessionTool, config.ExtraProperties)
	}

	s.AddTool(GetSessionTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req v1.GetSessionRequest

		message := request.GetArguments()

		// Extract extra properties if configured
		for _, prop := range config.ExtraProperties {
			if propVal, ok := message[prop.Name]; ok {
				ctx = context.WithValue(ctx, prop.ContextKey, propVal)
			}
		}

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := srv.GetSession(ctx, &req)
		if err != nil {
			return runtime.HandleError(err)
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}

		return mcp.NewToolResultText(string(marshaled)), nil
	})
	ListSessionsTool := RunnerService_ListSessionsTool
	// Add extra properties to schema if configured
	if len(config.ExtraProperties) > 0 {
		ListSessionsTool = runtime.AddExtraPropertiesToTool(ListSessionsTool, config.ExtraProperties)
	}

	s.AddTool(ListSessionsTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req v1.ListSessionsRequest

		message := request.GetArguments()

		// Extract extra properties if configured
		for _, prop := range config.ExtraProperties {
			if propVal, ok := message[prop.Name]; ok {
				ctx = context.WithValue(ctx, prop.ContextKey, propVal)
			}
		}

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := srv.ListSessions(ctx, &req)
		if err != nil {
			return runtime.HandleError(err)
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}

		return mcp.NewToolResultText(string(marshaled)), nil
	})
	ResolveProgramTool := RunnerService_ResolveProgramTool
	// Add extra properties to schema if configured
	if len(config.ExtraProperties) > 0 {
		ResolveProgramTool = runtime.AddExtraPropertiesToTool(ResolveProgramTool, config.ExtraProperties)
	}

	s.AddTool(ResolveProgramTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req v1.ResolveProgramRequest

		message := request.GetArguments()

		// Extract extra properties if configured
		for _, prop := range config.ExtraProperties {
			if propVal, ok := message[prop.Name]; ok {
				ctx = context.WithValue(ctx, prop.ContextKey, propVal)
			}
		}

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := srv.ResolveProgram(ctx, &req)
		if err != nil {
			return runtime.HandleError(err)
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}

		return mcp.NewToolResultText(string(marshaled)), nil
	})
}

// RegisterRunnerServiceHandlerOpenAI registers OpenAI-compatible MCP handlers for RunnerService
func RegisterRunnerServiceHandlerOpenAI(s *mcpserver.MCPServer, srv RunnerServiceServer, opts ...runtime.Option) {
	config := runtime.NewConfig()
	for _, opt := range opts {
		opt(config)
	}
	CreateSessionToolOpenAI := RunnerService_CreateSessionToolOpenAI
	// Add extra properties to schema if configured
	if len(config.ExtraProperties) > 0 {
		CreateSessionToolOpenAI = runtime.AddExtraPropertiesToTool(CreateSessionToolOpenAI, config.ExtraProperties)
	}

	s.AddTool(CreateSessionToolOpenAI, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req v1.CreateSessionRequest

		message := request.GetArguments()

		// Extract extra properties if configured
		for _, prop := range config.ExtraProperties {
			if propVal, ok := message[prop.Name]; ok {
				ctx = context.WithValue(ctx, prop.ContextKey, propVal)
			}
		}

		runtime.FixOpenAI(req.ProtoReflect().Descriptor(), message)

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := srv.CreateSession(ctx, &req)
		if err != nil {
			return runtime.HandleError(err)
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}

		return mcp.NewToolResultText(string(marshaled)), nil
	})
	DeleteSessionToolOpenAI := RunnerService_DeleteSessionToolOpenAI
	// Add extra properties to schema if configured
	if len(config.ExtraProperties) > 0 {
		DeleteSessionToolOpenAI = runtime.AddExtraPropertiesToTool(DeleteSessionToolOpenAI, config.ExtraProperties)
	}

	s.AddTool(DeleteSessionToolOpenAI, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req v1.DeleteSessionRequest

		message := request.GetArguments()

		// Extract extra properties if configured
		for _, prop := range config.ExtraProperties {
			if propVal, ok := message[prop.Name]; ok {
				ctx = context.WithValue(ctx, prop.ContextKey, propVal)
			}
		}

		runtime.FixOpenAI(req.ProtoReflect().Descriptor(), message)

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := srv.DeleteSession(ctx, &req)
		if err != nil {
			return runtime.HandleError(err)
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}

		return mcp.NewToolResultText(string(marshaled)), nil
	})
	GetSessionToolOpenAI := RunnerService_GetSessionToolOpenAI
	// Add extra properties to schema if configured
	if len(config.ExtraProperties) > 0 {
		GetSessionToolOpenAI = runtime.AddExtraPropertiesToTool(GetSessionToolOpenAI, config.ExtraProperties)
	}

	s.AddTool(GetSessionToolOpenAI, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req v1.GetSessionRequest

		message := request.GetArguments()

		// Extract extra properties if configured
		for _, prop := range config.ExtraProperties {
			if propVal, ok := message[prop.Name]; ok {
				ctx = context.WithValue(ctx, prop.ContextKey, propVal)
			}
		}

		runtime.FixOpenAI(req.ProtoReflect().Descriptor(), message)

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := srv.GetSession(ctx, &req)
		if err != nil {
			return runtime.HandleError(err)
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}

		return mcp.NewToolResultText(string(marshaled)), nil
	})
	ListSessionsToolOpenAI := RunnerService_ListSessionsToolOpenAI
	// Add extra properties to schema if configured
	if len(config.ExtraProperties) > 0 {
		ListSessionsToolOpenAI = runtime.AddExtraPropertiesToTool(ListSessionsToolOpenAI, config.ExtraProperties)
	}

	s.AddTool(ListSessionsToolOpenAI, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req v1.ListSessionsRequest

		message := request.GetArguments()

		// Extract extra properties if configured
		for _, prop := range config.ExtraProperties {
			if propVal, ok := message[prop.Name]; ok {
				ctx = context.WithValue(ctx, prop.ContextKey, propVal)
			}
		}

		runtime.FixOpenAI(req.ProtoReflect().Descriptor(), message)

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := srv.ListSessions(ctx, &req)
		if err != nil {
			return runtime.HandleError(err)
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}

		return mcp.NewToolResultText(string(marshaled)), nil
	})
	ResolveProgramToolOpenAI := RunnerService_ResolveProgramToolOpenAI
	// Add extra properties to schema if configured
	if len(config.ExtraProperties) > 0 {
		ResolveProgramToolOpenAI = runtime.AddExtraPropertiesToTool(ResolveProgramToolOpenAI, config.ExtraProperties)
	}

	s.AddTool(ResolveProgramToolOpenAI, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req v1.ResolveProgramRequest

		message := request.GetArguments()

		// Extract extra properties if configured
		for _, prop := range config.ExtraProperties {
			if propVal, ok := message[prop.Name]; ok {
				ctx = context.WithValue(ctx, prop.ContextKey, propVal)
			}
		}

		runtime.FixOpenAI(req.ProtoReflect().Descriptor(), message)

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := srv.ResolveProgram(ctx, &req)
		if err != nil {
			return runtime.HandleError(err)
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}

		return mcp.NewToolResultText(string(marshaled)), nil
	})
}

// RegisterRunnerServiceHandlerWithProvider registers handlers for the specified LLM provider
func RegisterRunnerServiceHandlerWithProvider(s *mcpserver.MCPServer, srv RunnerServiceServer, provider runtime.LLMProvider, opts ...runtime.Option) {
	switch provider {
	case runtime.LLMProviderOpenAI:
		RegisterRunnerServiceHandlerOpenAI(s, srv, opts...)
	case runtime.LLMProviderStandard:
		fallthrough
	default:
		RegisterRunnerServiceHandler(s, srv, opts...)
	}
}

// RunnerServiceClient is compatible with the grpc-go client interface.
type RunnerServiceClient interface {
	CreateSession(ctx context.Context, req *v1.CreateSessionRequest, opts ...grpc.CallOption) (*v1.CreateSessionResponse, error)
	DeleteSession(ctx context.Context, req *v1.DeleteSessionRequest, opts ...grpc.CallOption) (*v1.DeleteSessionResponse, error)
	GetSession(ctx context.Context, req *v1.GetSessionRequest, opts ...grpc.CallOption) (*v1.GetSessionResponse, error)
	ListSessions(ctx context.Context, req *v1.ListSessionsRequest, opts ...grpc.CallOption) (*v1.ListSessionsResponse, error)
	ResolveProgram(ctx context.Context, req *v1.ResolveProgramRequest, opts ...grpc.CallOption) (*v1.ResolveProgramResponse, error)
}

// ConnectRunnerServiceClient is compatible with the connectrpc-go client interface.
type ConnectRunnerServiceClient interface {
	CreateSession(ctx context.Context, req *connect.Request[v1.CreateSessionRequest]) (*connect.Response[v1.CreateSessionResponse], error)
	DeleteSession(ctx context.Context, req *connect.Request[v1.DeleteSessionRequest]) (*connect.Response[v1.DeleteSessionResponse], error)
	GetSession(ctx context.Context, req *connect.Request[v1.GetSessionRequest]) (*connect.Response[v1.GetSessionResponse], error)
	ListSessions(ctx context.Context, req *connect.Request[v1.ListSessionsRequest]) (*connect.Response[v1.ListSessionsResponse], error)
	ResolveProgram(ctx context.Context, req *connect.Request[v1.ResolveProgramRequest]) (*connect.Response[v1.ResolveProgramResponse], error)
}

// ForwardToConnectRunnerServiceClient registers a connectrpc client, to forward MCP calls to it.
func ForwardToConnectRunnerServiceClient(s *mcpserver.MCPServer, client ConnectRunnerServiceClient, opts ...runtime.Option) {
	config := runtime.NewConfig()
	for _, opt := range opts {
		opt(config)
	}
	CreateSessionTool := RunnerService_CreateSessionTool
	// Add extra properties to schema if configured
	if len(config.ExtraProperties) > 0 {
		CreateSessionTool = runtime.AddExtraPropertiesToTool(CreateSessionTool, config.ExtraProperties)
	}

	s.AddTool(CreateSessionTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req v1.CreateSessionRequest

		message := request.GetArguments()

		// Extract extra properties if configured
		for _, prop := range config.ExtraProperties {
			if propVal, ok := message[prop.Name]; ok {
				ctx = context.WithValue(ctx, prop.ContextKey, propVal)
			}
		}

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := client.CreateSession(ctx, connect.NewRequest(&req))
		if err != nil {
			return runtime.HandleError(err)
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp.Msg)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
	})
	DeleteSessionTool := RunnerService_DeleteSessionTool
	// Add extra properties to schema if configured
	if len(config.ExtraProperties) > 0 {
		DeleteSessionTool = runtime.AddExtraPropertiesToTool(DeleteSessionTool, config.ExtraProperties)
	}

	s.AddTool(DeleteSessionTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req v1.DeleteSessionRequest

		message := request.GetArguments()

		// Extract extra properties if configured
		for _, prop := range config.ExtraProperties {
			if propVal, ok := message[prop.Name]; ok {
				ctx = context.WithValue(ctx, prop.ContextKey, propVal)
			}
		}

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := client.DeleteSession(ctx, connect.NewRequest(&req))
		if err != nil {
			return runtime.HandleError(err)
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp.Msg)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
	})
	GetSessionTool := RunnerService_GetSessionTool
	// Add extra properties to schema if configured
	if len(config.ExtraProperties) > 0 {
		GetSessionTool = runtime.AddExtraPropertiesToTool(GetSessionTool, config.ExtraProperties)
	}

	s.AddTool(GetSessionTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req v1.GetSessionRequest

		message := request.GetArguments()

		// Extract extra properties if configured
		for _, prop := range config.ExtraProperties {
			if propVal, ok := message[prop.Name]; ok {
				ctx = context.WithValue(ctx, prop.ContextKey, propVal)
			}
		}

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := client.GetSession(ctx, connect.NewRequest(&req))
		if err != nil {
			return runtime.HandleError(err)
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp.Msg)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
	})
	ListSessionsTool := RunnerService_ListSessionsTool
	// Add extra properties to schema if configured
	if len(config.ExtraProperties) > 0 {
		ListSessionsTool = runtime.AddExtraPropertiesToTool(ListSessionsTool, config.ExtraProperties)
	}

	s.AddTool(ListSessionsTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req v1.ListSessionsRequest

		message := request.GetArguments()

		// Extract extra properties if configured
		for _, prop := range config.ExtraProperties {
			if propVal, ok := message[prop.Name]; ok {
				ctx = context.WithValue(ctx, prop.ContextKey, propVal)
			}
		}

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := client.ListSessions(ctx, connect.NewRequest(&req))
		if err != nil {
			return runtime.HandleError(err)
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp.Msg)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
	})
	ResolveProgramTool := RunnerService_ResolveProgramTool
	// Add extra properties to schema if configured
	if len(config.ExtraProperties) > 0 {
		ResolveProgramTool = runtime.AddExtraPropertiesToTool(ResolveProgramTool, config.ExtraProperties)
	}

	s.AddTool(ResolveProgramTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req v1.ResolveProgramRequest

		message := request.GetArguments()

		// Extract extra properties if configured
		for _, prop := range config.ExtraProperties {
			if propVal, ok := message[prop.Name]; ok {
				ctx = context.WithValue(ctx, prop.ContextKey, propVal)
			}
		}

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := client.ResolveProgram(ctx, connect.NewRequest(&req))
		if err != nil {
			return runtime.HandleError(err)
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp.Msg)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
	})
}

// ForwardToRunnerServiceClient registers a gRPC client, to forward MCP calls to it.
func ForwardToRunnerServiceClient(s *mcpserver.MCPServer, client RunnerServiceClient, opts ...runtime.Option) {
	config := runtime.NewConfig()
	for _, opt := range opts {
		opt(config)
	}
	CreateSessionTool := RunnerService_CreateSessionTool
	// Add extra properties to schema if configured
	if len(config.ExtraProperties) > 0 {
		CreateSessionTool = runtime.AddExtraPropertiesToTool(CreateSessionTool, config.ExtraProperties)
	}

	s.AddTool(CreateSessionTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req v1.CreateSessionRequest

		message := request.GetArguments()

		// Extract extra properties if configured
		for _, prop := range config.ExtraProperties {
			if propVal, ok := message[prop.Name]; ok {
				ctx = context.WithValue(ctx, prop.ContextKey, propVal)
			}
		}

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := client.CreateSession(ctx, &req)
		if err != nil {
			return runtime.HandleError(err)
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
	})
	DeleteSessionTool := RunnerService_DeleteSessionTool
	// Add extra properties to schema if configured
	if len(config.ExtraProperties) > 0 {
		DeleteSessionTool = runtime.AddExtraPropertiesToTool(DeleteSessionTool, config.ExtraProperties)
	}

	s.AddTool(DeleteSessionTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req v1.DeleteSessionRequest

		message := request.GetArguments()

		// Extract extra properties if configured
		for _, prop := range config.ExtraProperties {
			if propVal, ok := message[prop.Name]; ok {
				ctx = context.WithValue(ctx, prop.ContextKey, propVal)
			}
		}

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := client.DeleteSession(ctx, &req)
		if err != nil {
			return runtime.HandleError(err)
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
	})
	GetSessionTool := RunnerService_GetSessionTool
	// Add extra properties to schema if configured
	if len(config.ExtraProperties) > 0 {
		GetSessionTool = runtime.AddExtraPropertiesToTool(GetSessionTool, config.ExtraProperties)
	}

	s.AddTool(GetSessionTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req v1.GetSessionRequest

		message := request.GetArguments()

		// Extract extra properties if configured
		for _, prop := range config.ExtraProperties {
			if propVal, ok := message[prop.Name]; ok {
				ctx = context.WithValue(ctx, prop.ContextKey, propVal)
			}
		}

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := client.GetSession(ctx, &req)
		if err != nil {
			return runtime.HandleError(err)
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
	})
	ListSessionsTool := RunnerService_ListSessionsTool
	// Add extra properties to schema if configured
	if len(config.ExtraProperties) > 0 {
		ListSessionsTool = runtime.AddExtraPropertiesToTool(ListSessionsTool, config.ExtraProperties)
	}

	s.AddTool(ListSessionsTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req v1.ListSessionsRequest

		message := request.GetArguments()

		// Extract extra properties if configured
		for _, prop := range config.ExtraProperties {
			if propVal, ok := message[prop.Name]; ok {
				ctx = context.WithValue(ctx, prop.ContextKey, propVal)
			}
		}

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := client.ListSessions(ctx, &req)
		if err != nil {
			return runtime.HandleError(err)
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
	})
	ResolveProgramTool := RunnerService_ResolveProgramTool
	// Add extra properties to schema if configured
	if len(config.ExtraProperties) > 0 {
		ResolveProgramTool = runtime.AddExtraPropertiesToTool(ResolveProgramTool, config.ExtraProperties)
	}

	s.AddTool(ResolveProgramTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req v1.ResolveProgramRequest

		message := request.GetArguments()

		// Extract extra properties if configured
		for _, prop := range config.ExtraProperties {
			if propVal, ok := message[prop.Name]; ok {
				ctx = context.WithValue(ctx, prop.ContextKey, propVal)
			}
		}

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := client.ResolveProgram(ctx, &req)
		if err != nil {
			return runtime.HandleError(err)
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
	})
}
